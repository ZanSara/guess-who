<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guess Who</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üßë</text></svg>">
    <link rel="stylesheet" href="style.css"> 
    <script src="openai.js"></script>
    <script src="anthropic.js"></script>
    <script src="gemini.js"></script>
    <script data-goatcounter="https://zansaradev.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>

    <meta name="author" content="Sara Zan">
    <meta name="description" content="Play 'Guess Who' against your favorite LLMs">

    <meta name="twitter:card" content="Play 'Guess Who' against your favorite LLMs">
    <meta name="twitter:title" content="Play 'Guess Who' with LLMs!">
    <meta name="twitter:description" content="Play 'Guess Who' against your favorite LLMs">

    <meta property="og:url" content="https://zansara.dev/guess-who/">
    <meta property="og:site_name" content="Play 'Guess Who' with LLMs!">
    <meta property="og:title" content="Play 'Guess Who' with LLMs!">
    <meta property="og:description" content="Play 'Guess Who' against your favorite LLMs">
    <meta property="og:locale" content="en">

    <meta name="msvalidate.01" content="CD2BB9B57B16AF914327870432D856C1">
    <meta name="yandex-verification" content="a886d3d5d2b57cb5">
    <link rel="canonical" href="https://zansara.dev/guess-who/"">
 
</head>
<body>
    <header>
        <h1>Play "Guess Who" with LLMs!</h1>
    </header>

    <!-- Tabbed Game Container -->
    <div class="game-container">
        <div class="tab-navigation">
            <button class="tab-button" onclick="switchTab('user-board')">Your Board</button>
            <button class="tab-button active" onclick="switchTab('chat')">Chat</button>
            <button class="tab-button" onclick="switchTab('llm-board')">LLM's Board</button>
        </div>
        
        <div class="tab-content">
            <!-- User's Board Tab -->
            <div class="tab-panel" id="user-board">
                <div class="board">
                    <div class="loading-board" id="loadingBoard">
                        Loading characters...
                    </div>
                    <div class="board-content" id="userBoardContent" style="display: none;">
                        <div class="selected-character-row">
                            <div class="selected-character-container" id="userSelectedContainer">
                                <!-- User's selected character will appear here -->
                            </div>
                        </div>
                        <div class="cards-grid" id="cardsGrid">
                            <!-- Character cards will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- LLM's Board Tab -->
            <div class="tab-panel" id="llm-board">
                <div class="llm-board">
                    <div class="loading-llm-board" id="loadingLLMBoard">
                        Loading LLM's board...
                    </div>AI
                    <div class="llm-board-content" id="llmBoardContent" style="display: none;">
                        <div class="selected-character-row">
                            <div class="selected-character-container" id="llmSelectedContainer">
                                <!-- AI's selected character will appear here -->
                            </div>
                        </div>
                        <div class="cards-grid" id="llmCardsGrid">
                            <!-- LLM character cards will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Chat Tab -->
            <div class="tab-panel active" id="chat">
                <div class="chat-container">
                    <div class="model-indicator-bar">
                        <span style="text-align: center;">Playing against:</span>
                        <span class="current-model" id="chatModelIndicator">...</span>
                        <button class="settings-button" onclick="showSettings()">Settings</button>
                        <button class="settings-button" onclick="showHelp()">Help</button>
                    </div>
                    <div class="chat-messages" id="chatMessages">
                        <button id="expandCollapseBtn">Expand</button>
                        <!-- Chat messages will appear here -->
                    </div>
                    <div class="chat-input" id="chatInputContainer" style="display: none;">
                        <input type="text" id="chatInput" placeholder="Type your message..." onkeypress="handleKeyPress(event)">
                        <button onclick="sendMessage()">Send</button>
                    </div>
                    <div class="start-game-container" id="startGameContainer">
                        <button class="start-game-button" onclick="startGame()">Start!</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- API Key Modal -->
    <div id="apiKeyModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Model Settings</h2>
                <button class="close-modal" onclick="closeModal()">&times;</button>
            </div>
            <div id="modalMessage"></div>            
            <div class="provider-selection">
                <div class="provider-option active" id="openaiProvider" onclick="selectProvider('openai')">
                    <div class="key-status" id="openaiKeyStatus"></div>
                    <strong>OpenAI</strong><br>
                </div>
                <div class="provider-option" id="anthropicProvider" onclick="selectProvider('anthropic')">
                    <div class="key-status" id="anthropicKeyStatus"></div>
                    <strong>Anthropic</strong><br>
                </div>
                <div class="provider-option" id="geminiProvider" onclick="selectProvider('gemini')">
                    <div class="key-status" id="geminiKeyStatus"></div>
                    <strong>Gemini</strong><br>
                </div>
            </div>
            
            <div class="model-selection">
                <label for="modelInput">Model Name (examples: <span id="modelNameExamples"></span>):</label>
                <input type="text" id="modelInput" placeholder="..." oninput="updateSelectedModel()">
                <div class="key-status-text" id="modelStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section current" id="openaiSection">
                <label for="openaiEndpointInput">API Endpoint:</label>
                <div class="key-input-group">
                    <input type="text" id="openaiEndpointInput" placeholder="https://api.openai.com/v1" oninput="saveEndpointToStorage()" />
                </div>
                <label style="margin-top:0.5rem;" for="openaiKeyInput">API Key:</label>
                <div class="key-input-wrapper">
                    <input type="password" id="openaiKeyInput" placeholder="sk-..." oninput="saveApiKeyToStorage('openai')" />
                    <span class="toggle-password">üëÅÔ∏è</span>
                </div>
                <div class="key-status-text" id="openaiKeyStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section" id="anthropicSection">
                <label for="anthropicKeyInput">API Key:</label>
                <div class="key-input-wrapper">
                    <input type="password" id="anthropicKeyInput" placeholder="sk-ant-..." oninput="saveApiKeyToStorage('anthropic')" />
                    <span class="toggle-password">üëÅÔ∏è</span>
                </div>
                <div class="key-status-text" id="anthropicKeyStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section" id="geminiSection">
                <label for="geminiKeyInput">API Key:</label>
                <div class="key-input-wrapper">
                    <input type="password" id="geminiKeyInput" placeholder="AIza..." oninput="saveApiKeyToStorage('gemini')" />
                    <span class="toggle-password">üëÅÔ∏è</span>
                </div>
                <div class="key-status-text" id="geminiKeyStatusText" style="display: none;"></div>
            </div>

            <details>
                <summary class="h2">Advanced</summary>
                
                <!-- Game Options Section -->
                <div class="game-options-section">
                    <h3>Game Options</h3>
                    <div class="option-item">
                        <label class="toggle-label">
                            <input type="checkbox" id="showLLMCharacter" onchange="toggleLLMCharacterVisibility()">
                            <span class="toggle-slider"></span>
                            Uncover LLM's selected character
                        </label>
                        <p class="option-description">Flip the LLM's character card to reveal its identity. It's <i>technically</i> cheating, but it's useful to make sure the LLM is not lying to you üòâ</p>
                    </div>
                </div>
                
                <!-- System Prompt Section -->
                <div class="system-prompt-section">
                    <h3>System Prompt</h3>
                    <p>Customize how the LLM behaves in the game. This controls the LLM's personality, knowledge, and gameplay style.</p>
                    <textarea id="systemPromptTextarea" class="system-prompt-textarea" placeholder="Enter your system prompt here..."></textarea>
                    <div class="system-prompt-actions">
                        <button class="load-prompt-btn" onclick="loadSimplePrompt()">Load Simple Prompt</button>
                        <button class="load-prompt-btn" onclick="loadSpelledOutPrompt()">Load Spelled Out Prompt</button>
                        <button class="reset-prompt-btn" onclick="resetSystemPrompt()">Reset to Default</button>
                    </div>
                </div>
            </details>

            <div style="display: flex; gap: 0.5rem; margin-top: 1.5rem;">
                <button onclick="testConfiguration()" style="background: linear-gradient(135deg, #88ff00 0%, #1df500 100%); color: white;">Test</button>
                <button onclick="saveConfiguration()" id="saveButton">Save</button>
                <button onclick="closeModal()">Cancel</button>
            </div>
            
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üïµÔ∏è Let's Play "Guess Who" with an LLM!</h2>
                <button class="close-modal" onclick="closeHelpModal()">&times;</button>
            </div>
            <p>
                With this little game you can try to play "Guess Who" against an LLM of your choice.
            </p>
            <h2>The Rules</h2>
            <p>
                If you are not familiar with "Guess Who", here is a quick recap of the rules:
            </p>
            <ul>
                <li>Each player has a board full of characters.</li>
                <li>Each players draws an additional random character.</li>
                <li>Your goal is to guess which character the other player has received by asking yes/no questions, such as "Is your character male?" or "Does your character have black hair?" and so on</li>
                <li>The first player to guess the opponent character's name wins.</li>
            </ul>
            <h2>Choose the LLM</h2>
            <p>
                Before you can play you have to <b>connect an LLM</b>. This game supports OpenAI-compatible endpoints, Anthropic and Gemini models. Just click on Settings, select your provider, type in the model name of the LLM you want to play against and add your API key. You can test that your setup works by clicking on the Test button.

                <details>
                    <summary>What's an API key?</summary>
                    <p>
                        An API key is similar to a password: it gives application access to a private resource. For example, have a look here to get your own OpenAI API key: <a href="https://help.openai.com/en/articles/4936850-where-do-i-find-my-openai-api-key">Where do I find my OpenAI API Key? - OpenAI Help Center</a>
                    </p>
                </details>
                <details>
                    <summary>No way I'm giving you my API keys dude</summary>
                    <p>
                        Legit! I wouldn't either. If you still want to play, you can <a href="https://github.com/ZanSara/guess-who">get the source code on GitHub</a> and run the game yourself. It's extremely easy! The entire game is an HTML file with a little JS and CSS on the side. No frameworks, no build systems, no Node.js, React or whatever. This game has no backend at all. It's fully hosted on GitHub Pages and everything is stored in your browser's local storage. Check the <a href="https://github.com/ZanSara/guess-who?tab=readme-ov-file">README</a> of the repo for more details, but it all boils down to running <a href="https://github.com/ZanSara/guess-who?tab=readme-ov-file#how-to-play">these three commands</a> on any modern Linux or Mac OS.
                    </p>
                </details>
                <details>
                    <summary>Can I play for free?</summary>
                    <p>
                        The game is free, but if you're using a hosted LLM you're likely going to be charged by the token. Check your provider's terms to learn how much the tokens cost in your specific case. Rest assured: in this game there's no hidden consumption of tokens. The LLM is used exclusively to chat with you, so in most cases it should cost very little per game (pennies or less).
                    </p>
                </details>
            </p>
            <img src="help/settings.png">
            <h2>Gameplay</h2>
            <p>
                You can communicate with the LLM through a free form chat, just like you would play with another person.
            </p>
            <img src="help/chat.png">
            <p>
                Your board will be on the left, with your chosen character at the top. You can remove characters from your board by clicking on them. Clicking on an eliminated character brings it back.
            </p>
            <img src="help/user-board.png">
            <p>
                You can also see the LLM's board to know how many characters it already filtered out and how close it is to winning.                
            </p>
            <img src="help/llm-board.png">
            <p>
                The LLM is in charge of declaring a winner. When you win, the LLM should declare you the winner:                
            </p>
            <img src="help/user-wins.png">
            <p>
                When you lose, you'll see this instead:               
            </p>
            <img src="help/llm-wins.png">

            <h2>For the pros</h2>
            <p>
                In the Settings window you can find some more tools. They are especially useful if you're trying to prove a point.
            </p>
            <ul>
                <li><b>Reveal character</b>: reveals the LLM's selected character. With this setting turned on, winning is trivial. However, in many cases the LLM will lie about its character's features (!!!) so it can come useful if you're suspecting your LLM's partner of cheating.</li>
                <li><b>System Prompt</b>: the system prompt is crucial to the behavior of the LLM. By modifying the system prompt you can alter completely the behavior of the LLM and try to make it play better/worse/differently. I prepared two system prompts that can be loaded with the press of a button:
                </li>
                <ul>
                    <li> the "simple" prompt: what I believe would be sufficient for a smart LLM such as GPT-5 or Claude Opus to play this game normally.</li>
                    <li> the "spelled-out" prompt: what I eventually had to use in order to make most LLMs get close to a gameplay that makes sense.</li>
                </ul>
            </ul>
            <h2>Why?</h2>
            <p>
                My original intent was to make LLMs play against each other and make a sort of leaderboard of their Guess Who prowess... but the results of my initial testing were so delirious that I needed to share this version too. <br>
                I am now collecting a few gameplays for a future post on my <a href="https://zansara.dev">blog</a>, which I will link here once ready (or you can subscribe to my <a href="https://zansara.substack.com/">Substack</a> to receive it in your inbox). If you stumble upon some odd behavior, please share it with me! You can find me on <a href="https://x.com/zansara_dev">Twitter/X</a>, <a href="https://bsky.app/profile/zansara.bsky.social">Bluesky</a>, <a href="https://mastodon.social/@zansara">Mastodon</a>, <a href="https://www.linkedin.com/in/sarazanzottera/">LinkedIn</a>, and of course via <a href="mailto:hello@zansara.dev">email</a>. 
                Needless to say, <a href="https://github.com/ZanSara/guess-who">contributions are welcome</a>.<br>
                Enjoy!
            </p>
        </div>
    </div>

    <script>
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.querySelector('.chat-input button');
        const apiKeyModal = document.getElementById('apiKeyModal');
        const helpModal = document.getElementById('helpModal');
        const modalMessage = document.getElementById('modalMessage');
        const saveButton = document.getElementById('saveButton');
        const modelInput = document.getElementById('modelInput');
        const modelStatusText = document.getElementById('modelStatusText');
        const modelNameExamples = document.getElementById('modelNameExamples');
        const chatModelIndicator = document.getElementById('chatModelIndicator');
        const openaiProvider = document.getElementById('openaiProvider');
        const anthropicProvider = document.getElementById('anthropicProvider');
        const geminiProvider = document.getElementById('geminiProvider');
        
        // New elements for multi-key support
        const openaiKeyInput = document.getElementById('openaiKeyInput');
        const openaiEndpointInput = document.getElementById('openaiEndpointInput');
        const anthropicKeyInput = document.getElementById('anthropicKeyInput');
        const geminiKeyInput = document.getElementById('geminiKeyInput');
        const openaiKeyStatus = document.getElementById('openaiKeyStatus');
        const anthropicKeyStatus = document.getElementById('anthropicKeyStatus');
        const geminiKeyStatus = document.getElementById('geminiKeyStatus');
        const openaiSection = document.getElementById('openaiSection');
        const anthropicSection = document.getElementById('anthropicSection');
        const geminiSection = document.getElementById('geminiSection');
        const openaiKeyStatusText = document.getElementById('openaiKeyStatusText');
        const anthropicKeyStatusText = document.getElementById('anthropicKeyStatusText');
        const geminiKeyStatusText = document.getElementById('geminiKeyStatusText');
        const expandCollapseBtn = document.getElementById('expandCollapseBtn');
        
        // Game board elements
        const loadingBoard = document.getElementById('loadingBoard');
        const cardsGrid = document.getElementById('cardsGrid');
        const loadingLLMBoard = document.getElementById('loadingLLMBoard');
        const llmCardsGrid = document.getElementById('llmCardsGrid');
        const systemPromptTextarea = document.getElementById('systemPromptTextarea');

        // Default game system prompt (loaded from file)
        let DEFAULT_GAME_SYSTEM_PROMPT = '';

        // Current system prompt (editable)
        let GAME_SYSTEM_PROMPT = localStorage.getItem('custom-system-prompt') || DEFAULT_GAME_SYSTEM_PROMPT;
        
        // Game options
        let showLLMCharacter = localStorage.getItem('show-llm-character') === 'true';

        // Load default system prompt from file
        async function loadDefaultSystemPrompt() {
            try {
                const response = await fetch('prompts/simple.txt');
                if (response.ok) {
                    DEFAULT_GAME_SYSTEM_PROMPT = await response.text();
                    // Update GAME_SYSTEM_PROMPT if no custom prompt is set
                    if (!localStorage.getItem('custom-system-prompt')) {
                        GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                    }
                } else {
                    console.warn('Could not load default system prompt file');
                    // Fallback to a basic prompt
                    DEFAULT_GAME_SYSTEM_PROMPT = 'You are an AI assistant playing "Guess Who" with the user.';
                    if (!localStorage.getItem('custom-system-prompt')) {
                        GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                    }
                }
            } catch (error) {
                console.error('Error loading default system prompt:', error);
                // Fallback to a basic prompt
                DEFAULT_GAME_SYSTEM_PROMPT = 'You are an AI assistant playing "Guess Who" with the user.';
                if (!localStorage.getItem('custom-system-prompt')) {
                    GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                }
            }
        }

        // Configuration storage
        let currentProvider = localStorage.getItem('ai-provider') || '';
        let currentModel = localStorage.getItem('ai-model') || '';
        let apiKeys = {
            openai: localStorage.getItem('openai-api-key'),
            anthropic: localStorage.getItem('anthropic-api-key'),
            gemini: localStorage.getItem('gemini-api-key'),
        };
        let isProcessing = false;

        // Character data
        const characters = [
            'Abigail', 'Alex', 'Alice', 'Amy', 'Andy', 'Ashley', 'Brandon', 'Brian',
            'Daniel', 'David', 'Emily', 'Henry', 'Jake', 'James', 'Joe', 'Jon',
            'Joseph', 'Joshua', 'Justin', 'Kyle', 'Matt', 'Megan', 'Melissa',
            'Nick', 'Peter', 'Rachael', 'Tyler', 'William'
        ];

        let gameState = {
            characters: [],
            eliminated: new Set(),
            llmEliminated: new Set(),
            userChosenCharacter: null,
            opponentChosenCharacter: null
        };

        // Initialize AI providers
        const providers = {
            openai: new OpenAIProvider(),
            anthropic: new AnthropicProvider(),
            gemini: new GeminiProvider(),
        };

        function updateKeyStatusIndicators() {
            // Update OpenAI key status indicator
            if (apiKeys.openai) {
                openaiKeyStatus.classList.add('has-key');
            } else {
                openaiKeyStatus.classList.remove('has-key');
            }

            // Update Anthropic key status indicator
            if (apiKeys.anthropic) {
                anthropicKeyStatus.classList.add('has-key');
            } else {
                anthropicKeyStatus.classList.remove('has-key');
            }

            // Update Gemini key status indicator
            if (apiKeys.gemini) {
                geminiKeyStatus.classList.add('has-key');
            } else {
                geminiKeyStatus.classList.remove('has-key');
            }
        }

        function updateModelIndicator() {
            if (chatModelIndicator) {
                chatModelIndicator.textContent = currentModel;
            }
        }

        function selectProvider(provider) {
            currentProvider = provider;
            
            // Update provider selection UI
            openaiProvider.classList.remove('active');
            anthropicProvider.classList.remove('active');
            geminiProvider.classList.remove('active');
            document.getElementById(provider + 'Provider').classList.add('active');
            
            // Update section highlighting
            openaiSection.classList.remove('current');
            anthropicSection.classList.remove('current');
            geminiSection.classList.remove('current');
            document.getElementById(provider + 'Section').classList.add('current');
            
            // Update model input
            updateModelInput();
            updateModelIndicator();
        }

        function updateModelInput() {
            const provider = providers[currentProvider];
            
            // Update the examples span with provider's example models
            modelNameExamples.textContent = provider.exampleModels || 'No examples available';
            
            // Clear the model field when switching providers
            currentModel = localStorage.getItem(`${currentProvider}-ai-model`) || '';
            modelInput.value = currentModel;
            
            // Clear any previous validation status
            modelStatusText.style.display = 'none';
        }

        function updateSelectedModel() {
            const newModel = modelInput.value.trim();
            currentModel = newModel;
            // Update the model indicator
            updateModelIndicator();
            // Save the new model selection
            localStorage.setItem('ai-model', currentModel);
            localStorage.setItem(`${currentProvider}-ai-model`, currentModel);
            // Clear any previous validation status when model changes
            modelStatusText.style.display = 'none';
        }
        
        async function testConfiguration() {
            // Clear previous messages
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
            
            // Get current configuration
            const modelName = modelInput.value.trim();
            const provider = providers[currentProvider];
            
            // Validate required fields based on provider
            let missingFields = [];
            
            // Check model name
            if (!modelName) {
                missingFields.push('Model Name');
            }
            
            // Check API key
            let apiKey = '';
            if (currentProvider === 'openai') {
                apiKey = openaiKeyInput.value.trim();
                if (!apiKey) {
                    missingFields.push('API Key');
                }
                const endpoint = openaiEndpointInput.value.trim();
                if (!endpoint) {
                    missingFields.push('API Endpoint');
                }
            } else if (currentProvider === 'anthropic') {
                apiKey = anthropicKeyInput.value.trim();
                if (!apiKey) {
                    missingFields.push('API Key');
                }
            } else if (currentProvider === 'gemini') {
                apiKey = geminiKeyInput.value.trim();
                if (!apiKey) {
                    missingFields.push('API Key');
                }
            }
            
            // Show error if any fields are missing
            if (missingFields.length > 0) {
                showModalMessage(`Missing required fields: ${missingFields.join(', ')}`, true);
                return;
            }
            
            // Show testing status
            showModalMessage('Testing configuration...', false);
            
            try {
                // Test the complete configuration
                await provider.validateApiKey(apiKey, modelName);
                showModalMessage('‚úÖ Configuration is valid and working!', false);
            } catch (error) {
                console.error('Configuration test failed:', error);
                showModalMessage(`‚ùå Configuration test failed: ${error.message}`, true);
            }
        }
        
        function showModelStatus(message, status) {
            modelStatusText.textContent = message;
            modelStatusText.className = `key-status-text ${status}`;
            modelStatusText.style.display = 'block';
        }
        
        function saveEndpointToStorage() {
            const endpoint = openaiEndpointInput.value.trim();
            if (endpoint) {
                localStorage.setItem('openai-endpoint', endpoint);
            } else {
                localStorage.removeItem('openai-endpoint');
            }
        }
        
        function saveApiKeyToStorage(provider) {
            let keyInput, storageKey;
            
            if (provider === 'openai') {
                keyInput = openaiKeyInput;
                storageKey = 'openai-api-key';
            } else if (provider === 'anthropic') {
                keyInput = anthropicKeyInput;
                storageKey = 'anthropic-api-key';
            } else if (provider === 'gemini') {
                keyInput = geminiKeyInput;
                storageKey = 'gemini-api-key';
            }
            
            const key = keyInput.value.trim();
            if (key) {
                localStorage.setItem(storageKey, key);
                apiKeys[provider] = key;
            } else {
                localStorage.removeItem(storageKey);
                apiKeys[provider] = null;
            }
            
            // Update key status indicators
            updateKeyStatusIndicators();
        }
        
        function showSettings() {
            // Set up the modal with current configuration
            selectProvider(currentProvider || 'openai');
            modelInput.value = localStorage.getItem(`${currentProvider}-ai-model`) || '';;
            
            // Populate existing API keys and endpoint
            if (apiKeys.openai) {
                openaiKeyInput.value = apiKeys.openai;
            }
            // Populate OpenAI endpoint
            const savedEndpoint = localStorage.getItem('openai-endpoint');
            if (savedEndpoint) {
                openaiEndpointInput.value = savedEndpoint;
            } else {
                openaiEndpointInput.value = providers.openai.defaultEndpoint;
            }
            if (apiKeys.anthropic) {
                anthropicKeyInput.value = apiKeys.anthropic;
            }
            if (apiKeys.gemini) {
                geminiKeyInput.value = apiKeys.gemini;
            }
            // Populate system prompt textarea
            systemPromptTextarea.value = GAME_SYSTEM_PROMPT;
            
            // Set checkbox state for LLM character visibility
            document.getElementById('showLLMCharacter').checked = showLLMCharacter;
            
            // Update key status indicators
            updateKeyStatusIndicators();
            
            // Clear any previous messages
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
            
            apiKeyModal.style.display = 'block';
        }

        function showModalMessage(message, isError = false) {
            modalMessage.innerHTML = `<div class="${isError ? 'error-message' : 'success-message'}">${message}</div>`;
        }

        function closeModal() {
            apiKeyModal.style.display = 'none';
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
        }

        function showHelp() {
            helpModal.style.display = 'block';
        }

        function closeHelpModal() {
            helpModal.style.display = 'none';
        }

        function clearAllKeyStatusTexts() {
            openaiKeyStatusText.style.display = 'none';
            anthropicKeyStatusText.style.display = 'none';
            geminiKeyStatusText.style.display = 'none';
        }

        function showKeyStatus(provider, message, status) {
            let statusElement;
            if (provider === 'openai') {
                statusElement = openaiKeyStatusText;
            } else if (provider === 'anthropic') {
                statusElement = anthropicKeyStatusText;
            } else if (provider === 'gemini') {
                statusElement = geminiKeyStatusText;
            }
            statusElement.textContent = message;
            statusElement.className = `key-status-text ${status}`;
            statusElement.style.display = 'block';
        }

        async function saveConfiguration() {
            const openaiKey = openaiKeyInput.value.trim();
            const anthropicKey = anthropicKeyInput.value.trim();
            const geminiKey = geminiKeyInput.value.trim();
            
            // Validate that the selected provider has a key
            let selectedProviderKey;
            if (currentProvider === 'openai') {
                selectedProviderKey = openaiKey;
            } else if (currentProvider === 'anthropic') {
                selectedProviderKey = anthropicKey;
            } else if (currentProvider === 'gemini') {
                selectedProviderKey = geminiKey;
            }

            if (!selectedProviderKey) {
                showModalMessage(`Please enter an API key for ${currentProvider.charAt(0).toUpperCase() + currentProvider.slice(1)} to use this provider.`, true);
                return;
            }

            saveButton.disabled = true;

            try {
                // Save OpenAI key if provided
                if (openaiKey) {
                    apiKeys.openai = openaiKey;
                    localStorage.setItem('openai-api-key', openaiKey);
                } else if (apiKeys.openai) {
                    // Keep existing key if no new one provided
                    openaiKeyInput.value = apiKeys.openai;
                }
                
                // Save OpenAI endpoint
                if (openaiEndpointInput) {
                    providers.openai.setEndpoint(openaiEndpointInput.value);
                } else {
                    // Use default endpoint if empty
                    providers.openai.setEndpoint(providers.openai.defaultEndpoint);
                    openaiEndpointInput.value = providers.openai.defaultEndpoint;
                }

                // Save Anthropic key if provided
                if (anthropicKey) {
                    apiKeys.anthropic = anthropicKey;
                    localStorage.setItem('anthropic-api-key', anthropicKey);
                } else if (apiKeys.anthropic) {
                    // Keep existing key if no new one provided
                    anthropicKeyInput.value = apiKeys.anthropic;
                }

                // Save Gemini key if provided
                if (geminiKey) {
                    apiKeys.gemini = geminiKey;
                    localStorage.setItem('gemini-api-key', geminiKey);
                } else if (apiKeys.gemini) {
                    // Keep existing key if no new one provided
                    geminiKeyInput.value = apiKeys.gemini;
                }

                // Save system prompt
                const newPrompt = systemPromptTextarea.value.trim();
                if (newPrompt) {
                    GAME_SYSTEM_PROMPT = newPrompt;
                    localStorage.setItem('custom-system-prompt', newPrompt);
                } else {
                    GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                    localStorage.removeItem('custom-system-prompt');
                }

                // Save current provider and model
                const changedProvider = localStorage.getItem('ai-provider') !== currentProvider;
                localStorage.setItem('ai-provider', currentProvider);

                // Update UI
                updateModelIndicator();
                updateKeyStatusIndicators();

                // Close modal after delay
                setTimeout(() => {
                    closeModal();
                }, 500);

                // Reload the page if the provider was changed
                if (changedProvider) {
                    location.reload();
                }

            } catch (error) {
                showModalMessage(error.message, true);
            } finally {
                saveButton.disabled = false;
            }
        }


        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        function addMessage(content, isUser = false) {
            const messageElement = document.createElement('div');
            messageElement.className = `message ${isUser ? 'user-message' : 'gpt-message'}`;
            messageElement.textContent = content;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function showTypingIndicator() {
            const typingElement = document.createElement('div');
            typingElement.className = 'typing-indicator';
            typingElement.innerHTML = `
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            `;
            chatMessages.appendChild(typingElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            return typingElement;
        }

        function setProcessingState(processing) {
            isProcessing = processing;
            if (sendButton) {
                sendButton.disabled = processing;
            }
            if (chatInput) {
                chatInput.disabled = processing;
            }
        }

        // Function definitions for AI tools
        const ELIMINATE_CHARACTER_FUNCTION = {
            name: 'eliminateCharacter',
            description: 'Eliminate a character from your board when you learn they cannot be the user\'s character',
            parameters: {
                type: 'object',
                properties: {
                    characterName: {
                        type: 'string',
                        description: 'The exact name of the character to eliminate from the board',
                        enum: characters
                    }
                },
                required: ['characterName']
            }
        };

        const END_GAME_FUNCTION = {
            name: 'endGame',
            description: 'When you or the the user guesses correctly, the game should end.',
            parameters: {
                type: 'object',
                properties: {
                    winner: {
                        type: 'string',
                        description: 'either you (llm) or the user',
                        enum: ['llm', 'user']
                    }},
                required: ['winner']
            }
        };

        async function callAI(message) {
            console.log('callAI called with:', { message, currentProvider, hasApiKey: !!apiKeys[currentProvider] });
            
            if (!apiKeys[currentProvider]) {
                console.log('No API key found, showing modal');
                showSettings();
                return;
            }

            setProcessingState(true);
            const typingIndicator = showTypingIndicator();

            try {
                const provider = providers[currentProvider];
                if (!provider) {
                    throw new Error('Unsupported provider: ' + currentProvider);
                }
                
                console.log('Calling API for provider:', currentProvider);
                                
                const multimodalMessage = await provider.createMultimodalMessage(message);
                const response = await provider.callAPI(multimodalMessage, currentModel, [ELIMINATE_CHARACTER_FUNCTION, END_GAME_FUNCTION]);

                console.log('API response received, status:', response.status);

                // Stream the response - message element will be created when typing indicator is removed
                const result = await provider.streamResponse(response, null, typingIndicator);
                const aiResponse = result.response;
                const hasToolCalls = result.hasToolCalls;
                const toolCalls = result.toolCalls || [];
                
                // Execute tool calls if any
                if (toolCalls.length > 0) {
                    console.log('Executing tool calls:', toolCalls);
                    for (const toolCall of toolCalls) {
                        if (toolCall.function.name === 'eliminateCharacter') {
                            try {
                                const args = JSON.parse(toolCall.function.arguments);
                                const functionResult = eliminateCharacter(args.characterName);
                                console.log('Tool call result:', functionResult);
                                
                                // Display the elimination in the chat
                                if (functionResult.success) {
                                    const eliminationDiv = document.createElement('div');
                                    eliminationDiv.className = 'elimination-notice';
                                    eliminationDiv.textContent = `üö´ Eliminated: ${args.characterName}`;
                                    eliminationDiv.style.cssText = `
                                        background: rgba(255, 0, 0, 0.1);
                                        border-left: 3px solid #ff0000;
                                        padding: 8px 12px;
                                        margin: 4px 0;
                                        font-size: 0.9em;
                                        color: #666;
                                    `;
                                    chatMessages.appendChild(eliminationDiv);
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                }
                            } catch (e) {
                                console.error('Error executing tool call:', e);
                            }
                        } else if (toolCall.function.name === 'endGame') {
                            const args = JSON.parse(toolCall.function.arguments);
                            console.log("parsing arguments", args);
                            // Create confetti effect and congratulations popup
                            createConfetti();
                            showCongratulationsPopup(args.winner);
                        }
                    }
                }

            } catch (error) {
                console.error('Error calling LLM API:', error);
                
                // Remove typing indicator if still present
                if (typingIndicator && typingIndicator.parentNode) {
                    typingIndicator.remove();
                }
                
                // Create error message element
                const errorElement = document.createElement('div');
                errorElement.className = 'message gpt-message';
                errorElement.textContent = `Error: ${error.message}`;
                chatMessages.appendChild(errorElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                if (error.message.includes('Invalid API key')) {
                    apiKeys[currentProvider] = null;
                    localStorage.removeItem(`${currentProvider}-api-key`);
                    showSettings();
                }
            } finally {
                setProcessingState(false);
            }
        }

        function sendMessage() {
            const message = chatInput.value.trim();
            if (message && !isProcessing) {
                console.log('Sending message:', message);
                console.log('Current provider:', currentProvider);
                console.log('Has API key:', !!apiKeys[currentProvider]);
                
                addMessage(message, true);
                
                chatInput.value = '';
                callAI(message);
            } else {
                console.log('Message not sent - empty or processing:', { message: !!message, isProcessing });
            }
        }

        window.onclick = function(event) {
            if (event.target === apiKeyModal) {
                closeModal();
            }
            if (event.target == helpModal) {
                closeHelpModal();
            }
        }

        function resetSystemPrompt() {
            if (confirm('Are you sure you want to reset to the default system prompt? This will overwrite your current customizations.')) {
                GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                systemPromptTextarea.value = DEFAULT_GAME_SYSTEM_PROMPT;
                localStorage.removeItem('custom-system-prompt');
                
                // Show success feedback
                const resetButton = document.querySelector('.reset-prompt-btn');
                const originalText = resetButton.textContent;
                resetButton.textContent = 'Reset ‚úì';
                
                setTimeout(() => {
                    resetButton.textContent = originalText;
                }, 1000);
                
                console.log('System prompt reset to default');
            }
        }

        // Load simple prompt
        async function loadSimplePrompt() {
            try {
                const response = await fetch('prompts/simple.txt');
                if (response.ok) {
                    const promptText = await response.text();
                    systemPromptTextarea.value = promptText;
                    console.log('Simple prompt loaded');
                } else {
                    throw new Error(`Failed to load simple prompt: ${response.status}`);
                }
            } catch (error) {
                console.error('Error loading simple prompt:', error);
                alert('Failed to load simple prompt. Please check if the file exists.');
            }
        }

        // Load spelled-out prompt
        async function loadSpelledOutPrompt() {
            try {
                const response = await fetch('prompts/spelled-out.txt');
                if (response.ok) {
                    const promptText = await response.text();
                    systemPromptTextarea.value = promptText;
                    console.log('Spelled out prompt loaded');
                } else {
                    throw new Error(`Failed to load spelled out prompt: ${response.status}`);
                }
            } catch (error) {
                console.error('Error loading spelled out prompt:', error);
                alert('Failed to load spelled out prompt. Please check if the file exists.');
            }
        }

        // Game functions
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function createCharacterCard(name) {
            const card = document.createElement('div');
            card.className = 'character-card';
            card.dataset.character = name;
            card.onclick = () => toggleCardElimination(name);

            const img = document.createElement('img');
            img.src = `guess-who-people/${name}.png`;
            img.alt = name;
            img.onerror = () => {
                img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOTAiIGhlaWdodD0iMTIwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiNkZGQiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+Tm8gSW1hZ2U8L3RleHQ+PC9zdmc+';
            };

            card.appendChild(img);

            return card;
        }

        function createLLMCharacterCard(name) {
            const card = document.createElement('div');
            card.className = 'character-card';
            card.dataset.character = name;

            const img = document.createElement('img');
            img.src = `guess-who-people/${name}.png`;
            img.alt = name;
            img.onerror = () => {
                img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzAiIGhlaWdodD0iOTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0iI2RkZCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTAiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
            };

            card.appendChild(img);

            return card;
        }

        function toggleCardElimination(name) {
            const card = cardsGrid.querySelector(`[data-character="${name}"]`);
            if (gameState.eliminated.has(name)) {
                gameState.eliminated.delete(name);
                card.classList.remove('eliminated');
            } else {
                gameState.eliminated.add(name);
                card.classList.add('eliminated');
            }
        }


        // Helper functions for image loading
        async function getImageAsBase64(imageUrl) {
            try {
                const response = await fetch(imageUrl);
                if (!response.ok) {
                    throw new Error(`Failed to load image: ${response.status}`);
                }
                const blob = await response.blob();
                
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function() {
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error(`Failed to load image ${imageUrl}:`, error);
                return null;
            }
        }

        // Function for LLM to eliminate characters from its board
        function eliminateCharacter(characterName) {
            // Validate character name exists
            if (!characters.includes(characterName)) {
                console.warn(`Invalid character name: ${characterName}`);
                return { success: false, message: `Character "${characterName}" not found` };
            }

            // Check if already eliminated
            if (gameState.llmEliminated.has(characterName)) {
                return { success: false, message: `Character "${characterName}" is already eliminated` };
            }

            // Eliminate the character from LLM's board
            gameState.llmEliminated.add(characterName);
            const card = llmCardsGrid.querySelector(`[data-character="${characterName}"]`);
            if (card) {
                card.classList.add('eliminated');
            }

            console.log(`LLM eliminated character: ${characterName}`);
            return { success: true, message: `Successfully eliminated ${characterName}` };
        }

        function selectRandomCharacters() {
            const shuffledCharacters = shuffleArray([...characters]);
            gameState.userChosenCharacter = shuffledCharacters[0];
            gameState.opponentChosenCharacter = shuffledCharacters[1];
            
            console.log(`User's character: ${gameState.userChosenCharacter}`);
            console.log(`Opponent's character: ${gameState.opponentChosenCharacter}`);
        }

        function startGame() {
            // Hide the start game container and show the chat input
            const startGameContainer = document.getElementById('startGameContainer');
            const chatInputContainer = document.getElementById('chatInputContainer');
            
            startGameContainer.style.display = 'none';
            chatInputContainer.style.display = 'flex';
            
            // Generate the initial greeting
            generateInitialGreeting();
        }

        async function generateInitialGreeting() {
            try {
                // Check if we have a valid provider and API key
                if (!apiKeys[currentProvider]) {
                    console.log('No API key available for initial greeting');
                    showSettings();
                    return;
                }

                const provider = providers[currentProvider];
                if (!provider) {
                    console.error('Provider not available:', currentProvider);
                    addMessage('Error: LLM provider not available. Please check your configuration.', false);
                    return;
                }

                // Create a simple prompt to generate the greeting
                const greetingPrompt = "Generate a brief, friendly greeting message to start a Guess Who game. Tell the user whether you received the image of the board and your character and ask them for their first question. Keep it conversational and under 2 sentences.";
                
                console.log('Generating initial message...');
                
                // Set system prompt for the provider
                provider.setSystemPrompt(GAME_SYSTEM_PROMPT);

                // Add the board and the selected character to the chat history
                provider.addToHistory(provider.createMultimodalMessage('Here is the board:', await getImageAsBase64('full-board.png')));
                provider.addToHistory(provider.createMultimodalMessage('Here is YOUR character:', await getImageAsBase64(`guess-who-people/${gameState.opponentChosenCharacter}.png`)));
                
                // Show typing indicator and disable send button
                setProcessingState(true);
                const typingIndicator = showTypingIndicator();

                try {
                    const greetingMultimodal = await provider.createMultimodalMessage(greetingPrompt);
                    const response = await provider.callAPI(greetingMultimodal, currentModel, [ELIMINATE_CHARACTER_FUNCTION]);
                    
                    // Stream the response - message element will be created when typing indicator is removed
                    const result = await provider.streamResponse(response, null, typingIndicator);
                    console.log('Initial greeting generated successfully');
                    
                    // Re-enable send button after successful response
                    setProcessingState(false);
                    
                } catch (error) {
                    console.error('Could not generate initial greeting:', error);
                    
                    // Remove typing indicator if still present
                    if (typingIndicator && typingIndicator.parentNode) {
                        typingIndicator.remove();
                    }
                    
                    // Re-enable send button on error
                    setProcessingState(false);
                    
                    // Show error message and prompt for API key setup
                    addMessage(`Unable to connect to LLM service: ${error.message}`, false);
                    
                    if (error.message.includes('Invalid API key')) {
                        apiKeys[currentProvider] = null;
                        localStorage.removeItem(`${currentProvider}-api-key`);
                        showSettings();
                    }
                }

            } catch (error) {
                console.error('Error in generateInitialGreeting:', error);
                addMessage('Error starting the game. Please check your LLM configuration.', false);
            }
        }

        async function loadGameBoard(resetChat = true) {
            try {
                // Reset game state
                isFirstGameMessage = true;
                
                // Clear all provider conversation histories
                Object.values(providers).forEach(provider => {
                    provider.clearHistory();
                });
                
                // Select random characters for user and opponent
                selectRandomCharacters();
                
                // Shuffle all characters for the main grid (including selected ones)
                gameState.characters = shuffleArray(characters);
                gameState.eliminated.clear();
                gameState.llmEliminated.clear();

                // Clear existing cards
                cardsGrid.innerHTML = '';
                llmCardsGrid.innerHTML = '';
                document.getElementById('userSelectedContainer').innerHTML = '';
                document.getElementById('llmSelectedContainer').innerHTML = '';

                // Create selected character cards for top rows
                const userSelectedCard = createCharacterCard(gameState.userChosenCharacter);
                userSelectedCard.classList.add('top-selected-character');
                userSelectedCard.onclick = null; // Remove click functionality for top row
                document.getElementById('userSelectedContainer').appendChild(userSelectedCard);

                const llmSelectedCard = createLLMCharacterCard(gameState.opponentChosenCharacter);
                llmSelectedCard.classList.add('top-selected-character');
                document.getElementById('llmSelectedContainer').appendChild(llmSelectedCard);

                // Create and add all character cards for main grids (including selected characters)
                gameState.characters.forEach(name => {
                    // User's board
                    const userCard = createCharacterCard(name);
                    cardsGrid.appendChild(userCard);
                    
                    // LLM's board
                    const llmCard = createLLMCharacterCard(name);
                    llmCardsGrid.appendChild(llmCard);
                });

                // Clear chat messages for new game
                if (resetChat) {
                    const messagesToRemove = chatMessages.querySelectorAll('.message, .typing-indicator, .elimination-notice');
                    messagesToRemove.forEach(msg => msg.remove());
                }

                // Show both board contents and hide loading
                loadingBoard.style.display = 'none';
                document.getElementById('userBoardContent').style.display = 'block';
                loadingLLMBoard.style.display = 'none';
                document.getElementById('llmBoardContent').style.display = 'block';
                
                // Apply LLM character visibility setting
                updateLLMCharacterVisibility();

            } catch (error) {
                console.error('Error loading game board:', error);
                loadingBoard.textContent = 'Error loading characters. Please refresh to try again.';
                loadingLLMBoard.textContent = 'Error loading LLM board. Please refresh to try again.';
            }
        }

        function setupPasswordToggle() {
            document.querySelectorAll('.toggle-password').forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const input = toggle.previousElementSibling;
                    if (input.type === 'password') {
                        input.type = 'text';
                        toggle.textContent = 'üôà';
                    } else {
                        input.type = 'password';
                        toggle.textContent = 'üëÅÔ∏è';
                    }
                });
            });
        }

        // Initialize the app
        async function initializeApp() {
            // Load default system prompt first
            await loadDefaultSystemPrompt();
            
            updateModelIndicator();
            updateKeyStatusIndicators();
            
            // Load the game board
            loadGameBoard(true);
            setupPasswordToggle();

            if (!currentProvider) {
                showSettings();
            }
            if (!apiKeys[currentProvider]) {
                showSettings();
            }

            if (!localStorage.getItem('hasVisited')) {
                showHelp();
                localStorage.setItem('hasVisited', 'true');
            }

            expandCollapseBtn.addEventListener('click', () => {
                const chatContainer = expandCollapseBtn.closest('.chat-container');
                chatContainer.classList.toggle('expanded');

                if (chatContainer.classList.contains('expanded')) {
                    expandCollapseBtn.textContent = 'Collapse';
                } else {
                    expandCollapseBtn.textContent = 'Expand';
                }
            });
        }
        
        // Tab switching functionality
        function switchTab(tabName) {
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Remove active class from all tab panels
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Add active class to clicked button
            event.target.classList.add('active');
            
            // Show the selected tab panel
            document.getElementById(tabName).classList.add('active');
        }

        // Toggle LLM character visibility function
        function toggleLLMCharacterVisibility() {
            showLLMCharacter = document.getElementById('showLLMCharacter').checked;
            localStorage.setItem('show-llm-character', showLLMCharacter.toString());
            updateLLMCharacterVisibility();
        }

        // Update LLM character visibility function
        function updateLLMCharacterVisibility() {
            const llmSelectedCard = document.querySelector('#llmSelectedContainer .character-card');
            if (llmSelectedCard) {
                if (showLLMCharacter) {
                    llmSelectedCard.classList.remove('hidden-character');
                } else {
                    llmSelectedCard.classList.add('hidden-character');
                }
            }
        }

        // Confetti effect function
        function createConfetti() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffd93d', '#ffbe0b'];
            const confettiContainer = document.createElement('div');
            confettiContainer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 10000;
            `;
            document.body.appendChild(confettiContainer);

            // Create confetti pieces
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                const color = colors[Math.floor(Math.random() * colors.length)];
                const size = Math.random() * 10 + 5;
                const left = Math.random() * 100;
                const animationDuration = Math.random() * 3 + 2;
                const opacity = Math.random() * 0.7 + 0.3;

                confetti.style.cssText = `
                    position: absolute;
                    background-color: ${color};
                    width: ${size}px;
                    height: ${size}px;
                    left: ${left}%;
                    top: -10px;
                    opacity: ${opacity};
                    border-radius: ${Math.random() > 0.5 ? '50%' : '0'};
                    animation: confettiFall ${animationDuration}s linear forwards;
                `;

                confettiContainer.appendChild(confetti);
            }

            // Add confetti animation CSS
            if (!document.querySelector('#confetti-styles')) {
                const style = document.createElement('style');
                style.id = 'confetti-styles';
                style.textContent = `
                    @keyframes confettiFall {
                        0% {
                            transform: translateY(-10px) rotate(0deg);
                        }
                        100% {
                            transform: translateY(100vh) rotate(360deg);
                        }
                    }
                `;
                document.head.appendChild(style);
            }

            // Remove confetti after animation
            setTimeout(() => {
                confettiContainer.remove();
            }, 5000);
        }

        // Congratulations popup function
        function showCongratulationsPopup(winner) {
            // Create popup overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10001;
                animation: fadeIn 0.3s ease-out;
            `;

            // Create popup content
            const popup = document.createElement('div');
            popup.style.cssText = `
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 40px;
                border-radius: 20px;
                text-align: center;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                max-width: 400px;
                animation: popIn 0.4s ease-out;
                position: relative;
            `;

            // Add close button
            const closeButton = document.createElement('button');
            closeButton.innerHTML = '&times;';
            closeButton.className = 'close-modal';
            closeButton.style.position = 'absolute';
            closeButton.style.top = '10px';
            closeButton.style.right = '10px';
            closeButton.onclick = () => closeCongratulationsPopup(overlay);
            popup.appendChild(closeButton);

            if (winner === 'user') {
                popup.innerHTML += `
                    <div style="font-size: 60px; margin-bottom: 20px;">üéâ</div>
                    <h2 style="margin: 0 0 15px 0; font-size: 28px; font-weight: bold;">Congratulations!</h2>
                    <p style="margin: 0 0 25px 0; font-size: 16px; line-height: 1.4;">You won the game! üèÜ</p>
                    <button id="closePopup" style="
                        background-color: #fff;
                        color: #667eea;
                        border: none;
                        padding: 12px 30px;
                        border-radius: 25px;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        transition: transform 0.2s ease;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        New Game
                    </button>
                `;
            } else {
                popup.innerHTML += `
                    <div style="font-size: 60px; margin-bottom: 20px;">‚ò†Ô∏è</div>
                    <h2 style="margin: 0 0 15px 0; font-size: 28px; font-weight: bold;">Try again!</h2>
                    <p style="margin: 0 0 25px 0; font-size: 16px; line-height: 1.4;">You lost this time üò≠</p>
                    <button id="closePopup" style="
                        background-color: #fff;
                        color: #667eea;
                        border: none;
                        padding: 12px 30px;
                        border-radius: 25px;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        transition: transform 0.2s ease;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        New Game
                    </button>
                `;
            }
            

            // Add popup animations CSS
            if (!document.querySelector('#popup-styles')) {
                const style = document.createElement('style');
                style.id = 'popup-styles';
                style.textContent = `
                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    @keyframes popIn {
                        0% {
                            opacity: 0;
                            transform: scale(0.8) translateY(-10px);
                        }
                        100% {
                            opacity: 1;
                            transform: scale(1) translateY(0);
                        }
                    }
                `;
                document.head.appendChild(style);
            }

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            // Close popup handler
            document.getElementById('closePopup').onclick = () => closeCongratulationsPopup(overlay);

            // Close on overlay click
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    closeCongratulationsPopup(overlay);
                }
            };
        }

        function closeCongratulationsPopup(overlay) {
            overlay.style.animation = 'fadeIn 0.3s ease-out reverse';
            setTimeout(() => {
                overlay.remove();
                loadGameBoard(false);
            }, 300);
        }

        // Start the app
        initializeApp();
    </script>
    <footer>
        <p>
            Made by 
            <img src="https://zansara.dev/me/avatar.svg" style="width:20px;margin-bottom:-3px;"> 
            <a href="https://zansara.dev" target="_blank">Sara Zan</a> 
            with the help of
            <a href="https://www.anthropic.com/claude-code" target="_blank">ü§ñ</a>
            <a href="https://github.com/google-gemini/gemini-cli" target="_blank">ü§ñ</a>
        </p>
        <p>
            <a href="https://github.com/ZanSara/guess-who" target="_blank">
                <svg xmlns="http://www.w3.org/2000/svg" style="width:20px;margin-bottom:-3px;" aria-hidden="true" focusable="false" viewBox="0 0 512 512">
                    <path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3 .3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5 .3-6.2 2.3zm44.2-1.7c-2.9 .7-4.9 2.6-4.6 4.9 .3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3 .7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3 .3 2.9 2.3 3.9 1.6 1 3.6 .7 4.3-.7 .7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3 .7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3 .7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path>
                </svg>
            </a> &MediumSpace;
            <a href="https://x.com/zansara_dev" target="_blank">
                <svg xmlns="http://www.w3.org/2000/svg" style="width:20px;margin-bottom:-3px;" aria-hidden="true" focusable="false" viewBox="0 0 512 512">
                    <path fill="currentColor" d="M389.2 48h70.6L305.6 224.2 487 464H345L233.7 318.6 106.5 464H35.8L200.7 275.5 26.8 48H172.4L272.9 180.9 389.2 48zM364.4 421.8h39.1L151.1 88h-42L364.4 421.8z"></path>
                </svg>
            </a> &MediumSpace;
            <a href="https://bsky.app/profile/zansara.bsky.social" target="_blank">
                <svg xmlns="http://www.w3.org/2000/svg" style="width:20px;margin-bottom:-3px;" aria-hidden="true" focusable="false" viewBox="0 0 512 512">
                    <path fill="currentColor" d="M111.8 62.2C170.2 105.9 233 194.7 256 242.4c23-47.6 85.8-136.4 144.2-180.2c42.1-31.6 110.3-56 110.3 21.8c0 15.5-8.9 130.5-14.1 149.2C478.2 298 412 314.6 353.1 304.5c102.9 17.5 129.1 75.5 72.5 133.5c-107.4 110.2-154.3-27.6-166.3-62.9l0 0c-1.7-4.9-2.6-7.8-3.3-7.8s-1.6 3-3.3 7.8l0 0c-12 35.3-59 173.1-166.3 62.9c-56.5-58-30.4-116 72.5-133.5C100 314.6 33.8 298 15.7 233.1C10.4 214.4 1.5 99.4 1.5 83.9c0-77.8 68.2-53.4 110.3-21.8z"></path>
                </svg>
            </a> &MediumSpace;
            <a href="https://mastodon.social/@zansara" target="_blank">
                <svg xmlns="http://www.w3.org/2000/svg" style="width:20px;margin-bottom:-3px;" aria-hidden="true" focusable="false" viewBox="0 0 512 512">
                    <path fill="currentColor" d="M433 179.1c0-97.2-63.7-125.7-63.7-125.7-62.5-28.7-228.6-28.4-290.5 0 0 0-63.7 28.5-63.7 125.7 0 115.7-6.6 259.4 105.6 289.1 40.5 10.7 75.3 13 103.3 11.4 50.8-2.8 79.3-18.1 79.3-18.1l-1.7-36.9s-36.3 11.4-77.1 10.1c-40.4-1.4-83-4.4-89.6-54a102.5 102.5 0 0 1 -.9-13.9c85.6 20.9 158.7 9.1 178.8 6.7 56.1-6.7 105-41.3 111.2-72.9 9.8-49.8 9-121.5 9-121.5zm-75.1 125.2h-46.6v-114.2c0-49.7-64-51.6-64 6.9v62.5h-46.3V197c0-58.5-64-56.6-64-6.9v114.2H90.2c0-122.1-5.2-147.9 18.4-175 25.9-28.9 79.8-30.8 103.8 6.1l11.6 19.5 11.6-19.5c24.1-37.1 78.1-34.8 103.8-6.1 23.7 27.3 18.4 53 18.4 175z"></path>
                </svg>
            </a> &MediumSpace;
            <a href="https://zansara.substack.com/" target="_blank">
                <svg xmlns="http://www.w3.org/2000/svg" style="width:20px;margin-bottom:-3px;" aria-hidden="true" focusable="false" viewBox="0 0 512 512">
                    <path fill="currentColor" d="M0 48V487.7C0 501.1 10.9 512 24.3 512c5 0 9.9-1.5 14-4.4L192 400 345.7 507.6c4.1 2.9 9 4.4 14 4.4c13.4 0 24.3-10.9 24.3-24.3V48c0-26.5-21.5-48-48-48H48C21.5 0 0 21.5 0 48z"></path>
                </svg>
            </a> &MediumSpace;
            <a href="https://www.linkedin.com/in/sarazanzottera/" target="_blank">
                <svg xmlns="http://www.w3.org/2000/svg" style="width:20px;margin-bottom:-3px;" aria-hidden="true" focusable="false" viewBox="0 0 512 512">
                    <path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path>
                </svg>
            </a>

        </p>
    </footer>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guess Who</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üßë</text></svg>">
    <link rel="stylesheet" href="style.css"> 
    <script src="openai.js"></script>
    <script src="anthropic.js"></script>
    <script src="gemini.js"></script>
</head>
<body>
    <header>
        <h1>Play "Guess Who" with <span class="model-indicator" id="modelIndicator">...</span>!</h1>
    </header>
    
    <div class="api-key-status" id="apiKeyStatus" onclick="showApiKeyModal()">
        ‚öôÔ∏è
    </div>

    <div class="game-container">
        <div class="board">
            <div class="loading-board" id="loadingBoard">
                Loading characters...
            </div>
            <div class="cards-grid" id="cardsGrid" style="display: none;">
                <!-- Character cards will be loaded here -->
            </div>
        </div>
        <div class="chosen-characters">
            <div class="chosen-character">
                <h3>Your Character</h3>
                <div class="chosen-card" id="userChosenCard">
                    <img id="userChosenImage" src="" alt="">
                </div>
            </div>
            <div class="chosen-character">
                <h3>Opponent's Character</h3>
                <div class="chosen-card face-down" id="opponentChosenCard">
                </div>
            </div>
        </div>
        <div class="chat-container">
            <div class="chat-messages" id="chatMessages">
                <!-- Chat messages will appear here -->
            </div>
            <div class="chat-input">
                <input type="text" id="chatInput" placeholder="Type your message..." onkeypress="handleKeyPress(event)">
                <button onclick="sendMessage()">Send</button>
            </div>
        </div>
        <div class="llm-board">
            <div class="llm-board-header">
                <h3>AI's Board</h3>
            </div>
            <div class="loading-llm-board" id="loadingLLMBoard">
                Loading AI board...
            </div>
            <div class="llm-cards-grid" id="llmCardsGrid" style="display: none;">
                <!-- LLM character cards will be loaded here -->
            </div>
        </div>
    </div>

    <!-- API Key Modal -->
    <div id="apiKeyModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">AI Model Configuration</h2>
                <button class="close-modal" onclick="closeModal()">&times;</button>
            </div>
            <p id="modalDescription">Choose your AI provider and configure your API keys:</p>
            <div id="modalMessage"></div>
            
            <div class="provider-selection">
                <div class="provider-option active" id="openaiProvider" onclick="selectProvider('openai')">
                    <div class="key-status" id="openaiKeyStatus"></div>
                    <strong>OpenAI</strong><br>
                </div>
                <div class="provider-option" id="anthropicProvider" onclick="selectProvider('anthropic')">
                    <div class="key-status" id="anthropicKeyStatus"></div>
                    <strong>Anthropic</strong><br>
                </div>
                <div class="provider-option" id="geminiProvider" onclick="selectProvider('gemini')">
                    <div class="key-status" id="geminiKeyStatus"></div>
                    <strong>Google Gemini</strong><br>
                </div>
            </div>
            
            <div class="model-selection">
                <label for="modelSelect"><strong>Selected Model:</strong></label>
                <select id="modelSelect" onchange="updateSelectedModel()">
                    <option value="gpt-4o">GPT-4o</option>
                    <option value="gpt-4o-mini">GPT-4o Mini</option>
                    <option value="gpt-5">GPT-5</option>
                    <option value="gpt-5-mini">GPT-5 Mini</option>
                    <option value="gpt-5-nano">GPT-5 Nano</option>
                </select>
            </div>

            <div class="api-key-section current" id="openaiSection">
                <h4>OpenAI API Key</h4>
                <div class="key-input-group">
                    <div class="key-input-wrapper">
                        <input type="password" id="openaiKeyInput" placeholder="sk-..." />
                        <span class="toggle-password">üëÅÔ∏è</span>
                    </div>
                    <button class="validate-btn" onclick="validateProviderKey('openai')" id="openaiValidateBtn">Test Key</button>
                </div>
                <div class="key-status-text" id="openaiKeyStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section" id="anthropicSection">
                <h4>Anthropic API Key</h4>
                <div class="key-input-group">
                    <div class="key-input-wrapper">
                        <input type="password" id="anthropicKeyInput" placeholder="sk-ant-..." />
                        <span class="toggle-password">üëÅÔ∏è</span>
                    </div>
                    <button class="validate-btn" onclick="validateProviderKey('anthropic')" id="anthropicValidateBtn">Test Key</button>
                </div>
                <div class="key-status-text" id="anthropicKeyStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section" id="geminiSection">
                <h4>Gemini API Key</h4>
                <div class="key-input-group">
                    <div class="key-input-wrapper">
                        <input type="password" id="geminiKeyInput" placeholder="AIza..." />
                        <span class="toggle-password">üëÅÔ∏è</span>
                    </div>
                    <button class="validate-btn" onclick="validateProviderKey('gemini')" id="geminiValidateBtn">Test Key</button>
                </div>
                <div class="key-status-text" id="geminiKeyStatusText" style="display: none;"></div>
            </div>
            
            <!-- System Prompt Section -->
            <div class="system-prompt-section">
                <h3>System Prompt</h3>
                <p>Customize how the AI behaves in the game. This controls the AI's personality, knowledge, and gameplay style.</p>
                <textarea id="systemPromptTextarea" class="system-prompt-textarea" placeholder="Enter your system prompt here..."></textarea>
                <div class="system-prompt-actions">
                    <button class="reset-prompt-btn" onclick="resetSystemPrompt()">Reset to Default</button>
                </div>
            </div>
            
            <div>
                <button onclick="saveConfiguration()" id="saveButton">Save Configuration</button>
                <button onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.querySelector('.chat-input button');
        const apiKeyModal = document.getElementById('apiKeyModal');
        const apiKeyStatus = document.getElementById('apiKeyStatus');
        const modelIndicator = document.getElementById('modelIndicator');
        const modalMessage = document.getElementById('modalMessage');
        const saveButton = document.getElementById('saveButton');
        const modelSelect = document.getElementById('modelSelect');
        const openaiProvider = document.getElementById('openaiProvider');
        const anthropicProvider = document.getElementById('anthropicProvider');
        const geminiProvider = document.getElementById('geminiProvider');
        
        // New elements for multi-key support
        const openaiKeyInput = document.getElementById('openaiKeyInput');
        const anthropicKeyInput = document.getElementById('anthropicKeyInput');
        const geminiKeyInput = document.getElementById('geminiKeyInput');
        const openaiKeyStatus = document.getElementById('openaiKeyStatus');
        const anthropicKeyStatus = document.getElementById('anthropicKeyStatus');
        const geminiKeyStatus = document.getElementById('geminiKeyStatus');
        const openaiSection = document.getElementById('openaiSection');
        const anthropicSection = document.getElementById('anthropicSection');
        const geminiSection = document.getElementById('geminiSection');
        const openaiKeyStatusText = document.getElementById('openaiKeyStatusText');
        const anthropicKeyStatusText = document.getElementById('anthropicKeyStatusText');
        const geminiKeyStatusText = document.getElementById('geminiKeyStatusText');
        const openaiValidateBtn = document.getElementById('openaiValidateBtn');
        const anthropicValidateBtn = document.getElementById('anthropicValidateBtn');
        const geminiValidateBtn = document.getElementById('geminiValidateBtn');
        
        // Game board elements
        const loadingBoard = document.getElementById('loadingBoard');
        const cardsGrid = document.getElementById('cardsGrid');
        const loadingLLMBoard = document.getElementById('loadingLLMBoard');
        const llmCardsGrid = document.getElementById('llmCardsGrid');
        const systemPromptTextarea = document.getElementById('systemPromptTextarea');

        // Default game system prompt (loaded from file)
        let DEFAULT_GAME_SYSTEM_PROMPT = '';

        // Current system prompt (editable)
        let GAME_SYSTEM_PROMPT = localStorage.getItem('custom-system-prompt') || DEFAULT_GAME_SYSTEM_PROMPT;

        // Load default system prompt from file
        async function loadDefaultSystemPrompt() {
            try {
                const response = await fetch('default-system-prompt.txt');
                if (response.ok) {
                    DEFAULT_GAME_SYSTEM_PROMPT = await response.text();
                    // Update GAME_SYSTEM_PROMPT if no custom prompt is set
                    if (!localStorage.getItem('custom-system-prompt')) {
                        GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                    }
                } else {
                    console.warn('Could not load default system prompt file');
                    // Fallback to a basic prompt
                    DEFAULT_GAME_SYSTEM_PROMPT = 'You are an AI assistant playing "Guess Who" with the user.';
                    if (!localStorage.getItem('custom-system-prompt')) {
                        GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                    }
                }
            } catch (error) {
                console.error('Error loading default system prompt:', error);
                // Fallback to a basic prompt
                DEFAULT_GAME_SYSTEM_PROMPT = 'You are an AI assistant playing "Guess Who" with the user.';
                if (!localStorage.getItem('custom-system-prompt')) {
                    GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                }
            }
        }

        // Configuration storage
        let currentProvider = localStorage.getItem('ai-provider') || 'openai';
        let currentModel = localStorage.getItem('ai-model') || 'gpt-4o';
        let apiKeys = {
            openai: localStorage.getItem('openai-api-key'),
            anthropic: localStorage.getItem('anthropic-api-key'),
            gemini: localStorage.getItem('gemini-api-key')
        };
        let isProcessing = false;

        // Character data
        const characters = [
            'Abigail', 'Alex', 'Alice', 'Amy', 'Andy', 'Ashley', 'Brandon', 'Brian',
            'Daniel', 'David', 'Emily', 'Henry', 'Jake', 'James', 'Joe', 'Jon',
            'Joseph', 'Joshua', 'Justin', 'Kyle', 'Matt', 'Megan', 'Melissa',
            'Nick', 'Peter', 'Rachael', 'Tyler', 'William'
        ];

        let gameState = {
            characters: [],
            eliminated: new Set(),
            llmEliminated: new Set(),
            userChosenCharacter: null,
            opponentChosenCharacter: null
        };

        // Initialize AI providers
        const providers = {
            openai: new OpenAIProvider(),
            anthropic: new AnthropicProvider(),
            gemini: new GeminiProvider()
        };

        function updateApiKeyStatus() {
            const hasApiKey = apiKeys[currentProvider];
            if (hasApiKey) {
                apiKeyStatus.className = 'api-key-status set';
            } else {
                apiKeyStatus.className = 'api-key-status not-set';
            }
        }

        function updateKeyStatusIndicators() {
            // Update OpenAI key status indicator
            if (apiKeys.openai) {
                openaiKeyStatus.classList.add('has-key');
            } else {
                openaiKeyStatus.classList.remove('has-key');
            }

            // Update Anthropic key status indicator
            if (apiKeys.anthropic) {
                anthropicKeyStatus.classList.add('has-key');
            } else {
                anthropicKeyStatus.classList.remove('has-key');
            }

            // Update Gemini key status indicator
            if (apiKeys.gemini) {
                geminiKeyStatus.classList.add('has-key');
            } else {
                geminiKeyStatus.classList.remove('has-key');
            }
        }

        function updateModelIndicator() {
            const provider = providers[currentProvider];
            const modelName = provider.models.find(m => m.value === currentModel)?.name || currentModel;
            modelIndicator.textContent = modelName;
        }

        function selectProvider(provider) {
            currentProvider = provider;
            
            // Update provider selection UI
            openaiProvider.classList.remove('active');
            anthropicProvider.classList.remove('active');
            geminiProvider.classList.remove('active');
            document.getElementById(provider + 'Provider').classList.add('active');
            
            // Update section highlighting
            openaiSection.classList.remove('current');
            anthropicSection.classList.remove('current');
            geminiSection.classList.remove('current');
            document.getElementById(provider + 'Section').classList.add('current');
            
            // Update model dropdown
            updateModelDropdown();
            updateApiKeyStatus();
            updateModelIndicator();
        }

        function updateModelDropdown() {
            const provider = providers[currentProvider];
            modelSelect.innerHTML = '';
            
            provider.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.name;
                modelSelect.appendChild(option);
            });
            
            // Set model based on current selection or default
            const savedModel = localStorage.getItem('ai-model');
            if (savedModel && provider.models.some(m => m.value === savedModel)) {
                currentModel = savedModel;
            } else {
                // Set default model for provider
                currentModel = provider.defaultModel;
            }
            modelSelect.value = currentModel;
        }

        function updateSelectedModel() {
            const newModel = modelSelect.value;
            if (newModel !== currentModel) {
                currentModel = newModel;
                // Save the new model selection
                localStorage.setItem('ai-model', currentModel);
                // Reload the page to ensure clean state with new model
                location.reload();
            }
        }

        function showApiKeyModal() {
            const modalTitle = document.getElementById('modalTitle');
            const modalDescription = document.getElementById('modalDescription');
            
            modalTitle.textContent = 'Settings';
            modalDescription.textContent = 'Configure your AI provider, API keys, and system prompt:';
            
            // Set up the modal with current configuration
            selectProvider(currentProvider);
            modelSelect.value = currentModel;
            
            // Populate existing API keys
            if (apiKeys.openai) {
                openaiKeyInput.value = apiKeys.openai;
            }
            if (apiKeys.anthropic) {
                anthropicKeyInput.value = apiKeys.anthropic;
            }
            if (apiKeys.gemini) {
                geminiKeyInput.value = apiKeys.gemini;
            }
            
            // Populate system prompt textarea
            systemPromptTextarea.value = GAME_SYSTEM_PROMPT;
            
            // Update key status indicators
            updateKeyStatusIndicators();
            
            // Clear any previous messages
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
            
            apiKeyModal.style.display = 'block';
        }

        function showModalMessage(message, isError = false) {
            modalMessage.innerHTML = `<div class="${isError ? 'error-message' : 'success-message'}">${message}</div>`;
        }

        function closeModal() {
            apiKeyModal.style.display = 'none';
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
        }

        function clearAllKeyStatusTexts() {
            openaiKeyStatusText.style.display = 'none';
            anthropicKeyStatusText.style.display = 'none';
            geminiKeyStatusText.style.display = 'none';
        }

        function showKeyStatus(provider, message, status) {
            let statusElement;
            if (provider === 'openai') {
                statusElement = openaiKeyStatusText;
            } else if (provider === 'anthropic') {
                statusElement = anthropicKeyStatusText;
            } else {
                statusElement = geminiKeyStatusText;
            }
            statusElement.textContent = message;
            statusElement.className = `key-status-text ${status}`;
            statusElement.style.display = 'block';
        }

        async function validateProviderKey(provider) {
            let keyInput, validateBtn;
            if (provider === 'openai') {
                keyInput = openaiKeyInput;
                validateBtn = openaiValidateBtn;
            } else if (provider === 'anthropic') {
                keyInput = anthropicKeyInput;
                validateBtn = anthropicValidateBtn;
            } else {
                keyInput = geminiKeyInput;
                validateBtn = geminiValidateBtn;
            }
            const key = keyInput.value.trim();
            const providerInstance = providers[provider];

            if (!key) {
                showKeyStatus(provider, 'Please enter an API key', 'invalid');
                return false;
            }

            if (provider !== 'gemini' && !key.startsWith(providerInstance.keyPrefix)) {
                showKeyStatus(provider, `API key should start with "${providerInstance.keyPrefix}"`, 'invalid');
                return false;
            }

            validateBtn.disabled = true;
            validateBtn.textContent = 'Testing...';
            showKeyStatus(provider, 'Testing API key...', 'testing');

            try {
                // Get a default model for testing
                const testModel = providerInstance.models[0].value;
                
                await providerInstance.validateApiKey(key, testModel);

                showKeyStatus(provider, '‚úì API key is valid!', 'valid');
                return true;

            } catch (error) {
                showKeyStatus(provider, error.message, 'invalid');
                return false;
            } finally {
                validateBtn.disabled = false;
                validateBtn.textContent = 'Test Key';
            }
        }

        async function saveConfiguration() {
            const openaiKey = openaiKeyInput.value.trim();
            const anthropicKey = anthropicKeyInput.value.trim();
            const geminiKey = geminiKeyInput.value.trim();
            
            // Validate that the selected provider has a key
            let selectedProviderKey;
            if (currentProvider === 'openai') {
                selectedProviderKey = openaiKey;
            } else if (currentProvider === 'anthropic') {
                selectedProviderKey = anthropicKey;
            } else {
                selectedProviderKey = geminiKey;
            }

            if (!selectedProviderKey) {
                showModalMessage(`Please enter an API key for ${currentProvider.charAt(0).toUpperCase() + currentProvider.slice(1)} to use this provider.`, true);
                return;
            }

            saveButton.disabled = true;
            saveButton.textContent = 'Saving...';

            try {
                // Save OpenAI key if provided
                if (openaiKey) {
                    apiKeys.openai = openaiKey;
                    localStorage.setItem('openai-api-key', openaiKey);
                } else if (apiKeys.openai) {
                    // Keep existing key if no new one provided
                    openaiKeyInput.value = apiKeys.openai;
                }

                // Save Anthropic key if provided
                if (anthropicKey) {
                    apiKeys.anthropic = anthropicKey;
                    localStorage.setItem('anthropic-api-key', anthropicKey);
                } else if (apiKeys.anthropic) {
                    // Keep existing key if no new one provided
                    anthropicKeyInput.value = apiKeys.anthropic;
                }

                // Save Gemini key if provided
                if (geminiKey) {
                    apiKeys.gemini = geminiKey;
                    localStorage.setItem('gemini-api-key', geminiKey);
                } else if (apiKeys.gemini) {
                    // Keep existing key if no new one provided
                    geminiKeyInput.value = apiKeys.gemini;
                }

                // Save system prompt
                const newPrompt = systemPromptTextarea.value.trim();
                if (newPrompt) {
                    GAME_SYSTEM_PROMPT = newPrompt;
                    localStorage.setItem('custom-system-prompt', newPrompt);
                } else {
                    GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                    localStorage.removeItem('custom-system-prompt');
                }

                // Save current provider and model
                localStorage.setItem('ai-provider', currentProvider);
                localStorage.setItem('ai-model', currentModel);

                // Update UI
                updateApiKeyStatus();
                updateModelIndicator();
                updateKeyStatusIndicators();

                showModalMessage('Configuration saved successfully!', false);

                // Close modal after delay
                setTimeout(() => {
                    closeModal();
                }, 500);

            } catch (error) {
                showModalMessage(error.message, true);
            } finally {
                saveButton.disabled = false;
                saveButton.textContent = 'Save Configuration';
            }
        }





        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        function addMessage(content, isUser = false) {
            const messageElement = document.createElement('div');
            messageElement.className = `message ${isUser ? 'user-message' : 'gpt-message'}`;
            messageElement.textContent = content;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function showTypingIndicator() {
            const typingElement = document.createElement('div');
            typingElement.className = 'typing-indicator';
            typingElement.innerHTML = `
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            `;
            chatMessages.appendChild(typingElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            return typingElement;
        }

        function setProcessingState(processing) {
            isProcessing = processing;
            sendButton.disabled = processing;
            chatInput.disabled = processing;
            if (processing) {
                sendButton.textContent = 'Sending...';
            } else {
                sendButton.textContent = 'Send';
            }
        }

        async function getImageAsBase64(imagePath) {
            try {
                const response = await fetch(imagePath);
                const blob = await response.blob();
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64 = reader.result.split(',')[1]; // Remove data:image/png;base64, prefix
                        resolve(base64);
                    };
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('Error loading image:', error);
                return '';
            }
        }

        // Track if this is the first message of the game
        let isFirstGameMessage = true;
        
        // Conversation history
        let conversationHistory = [];

        // Function definitions for AI tools
        const ELIMINATE_CHARACTER_FUNCTION = {
            name: 'eliminateCharacter',
            description: 'Eliminate a character from your board when you learn they cannot be the user\'s character',
            parameters: {
                type: 'object',
                properties: {
                    characterName: {
                        type: 'string',
                        description: 'The exact name of the character to eliminate from the board',
                        enum: characters
                    }
                },
                required: ['characterName']
            }
        };

        async function callAI(message) {
            console.log('callAI called with:', { message, currentProvider, hasApiKey: !!apiKeys[currentProvider] });
            
            if (!apiKeys[currentProvider]) {
                console.log('No API key found, showing modal');
                showApiKeyModal();
                return;
            }

            setProcessingState(true);
            const typingIndicator = showTypingIndicator();

            try {
                const provider = providers[currentProvider];
                if (!provider) {
                    throw new Error('Unsupported provider: ' + currentProvider);
                }
                
                console.log('Calling API for provider:', currentProvider);
                
                // Add system prompt to conversation history if this is the first message
                let fullConversationHistory = [...conversationHistory];
                if (isFirstGameMessage) {
                    fullConversationHistory.unshift({
                        role: 'system',
                        content: GAME_SYSTEM_PROMPT
                    });
                }
                
                const response = await provider.callAPI(message, currentModel, fullConversationHistory);
                
                // After first message, set flag to false
                isFirstGameMessage = false;

                console.log('API response received, status:', response.status);

                // Remove typing indicator and create message element
                if (typingIndicator && typingIndicator.parentNode) {
                    typingIndicator.remove();
                }
                
                const aiMessageElement = document.createElement('div');
                aiMessageElement.className = 'message gpt-message';
                aiMessageElement.textContent = '';
                chatMessages.appendChild(aiMessageElement);

                // Stream the response
                const result = await provider.streamResponse(response, aiMessageElement);
                const aiResponse = result.response;
                const hasToolCalls = result.hasToolCalls;
                
                // Store AI response in conversation history using provider's format
                conversationHistory.push(provider.formatHistoryMessage('assistant', aiResponse));

                // If the response was only tool calls with no text, prompt again for a conversational response
                if (hasToolCalls && (!aiResponse || aiResponse.trim() === '')) {
                    console.log('AI response was only tool calls, prompting for conversational response...');
                    
                    // Add a follow-up message to get conversational response
                    const followUpMessage = "Please provide your response or next question.";
                    
                    // Add the follow-up message to conversation history
                    conversationHistory.push(provider.formatHistoryMessage('user', followUpMessage));
                    
                    const followUpResponse = await provider.callAPI(followUpMessage, currentModel, conversationHistory);
                    const followUpResult = await provider.streamResponse(followUpResponse, aiMessageElement);
                    const followUpText = followUpResult.response;

                    // Combine the responses
                    const combinedResponse = aiResponse + (aiResponse ? '\n\n' : '') + followUpText;

                    // Update the last assistant message in conversation history
                    conversationHistory[conversationHistory.length - 2] = provider.formatHistoryMessage('assistant', combinedResponse);

                    // Add the follow-up AI response to history
                    conversationHistory.push(provider.formatHistoryMessage('assistant', followUpText));
                }

            } catch (error) {
                console.error('Error calling AI API:', error);
                
                // Remove typing indicator if still present
                if (typingIndicator && typingIndicator.parentNode) {
                    typingIndicator.remove();
                }
                
                // Create error message element
                const errorElement = document.createElement('div');
                errorElement.className = 'message gpt-message';
                errorElement.textContent = `Error: ${error.message}`;
                chatMessages.appendChild(errorElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                if (error.message.includes('Invalid API key')) {
                    apiKeys[currentProvider] = null;
                    localStorage.removeItem(`${currentProvider}-api-key`);
                    updateApiKeyStatus();
                    showApiKeyModal();
                }
            } finally {
                setProcessingState(false);
            }
        }

        function sendMessage() {
            const message = chatInput.value.trim();
            if (message && !isProcessing) {
                console.log('Sending message:', message);
                console.log('Current provider:', currentProvider);
                console.log('Has API key:', !!apiKeys[currentProvider]);
                
                addMessage(message, true);
                
                // Add user message to conversation history using provider's format
                const provider = providers[currentProvider];
                conversationHistory.push(provider.formatHistoryMessage('user', message));
                
                chatInput.value = '';
                callAI(message);
            } else {
                console.log('Message not sent - empty or processing:', { message: !!message, isProcessing });
            }
        }

        window.onclick = function(event) {
            if (event.target === apiKeyModal) {
                closeModal();
            }
        }

        function resetSystemPrompt() {
            if (confirm('Are you sure you want to reset to the default system prompt? This will overwrite your current customizations.')) {
                GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                systemPromptTextarea.value = DEFAULT_GAME_SYSTEM_PROMPT;
                localStorage.removeItem('custom-system-prompt');
                
                // Show success feedback
                const resetButton = document.querySelector('.reset-prompt-btn');
                const originalText = resetButton.textContent;
                resetButton.textContent = 'Reset ‚úì';
                
                setTimeout(() => {
                    resetButton.textContent = originalText;
                }, 1000);
                
                console.log('System prompt reset to default');
            }
        }

        // Game functions
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function createCharacterCard(name) {
            const card = document.createElement('div');
            card.className = 'character-card';
            card.dataset.character = name;
            card.onclick = () => toggleCardElimination(name);

            const img = document.createElement('img');
            img.src = `guess-who-people/${name}.png`;
            img.alt = name;
            img.onerror = () => {
                img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOTAiIGhlaWdodD0iMTIwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiNkZGQiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+Tm8gSW1hZ2U8L3RleHQ+PC9zdmc+';
            };

            card.appendChild(img);

            return card;
        }

        function createLLMCharacterCard(name) {
            const card = document.createElement('div');
            card.className = 'llm-character-card';
            card.dataset.character = name;

            const img = document.createElement('img');
            img.src = `guess-who-people/${name}.png`;
            img.alt = name;
            img.onerror = () => {
                img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzAiIGhlaWdodD0iOTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0iI2RkZCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTAiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
            };

            card.appendChild(img);

            return card;
        }

        function toggleCardElimination(name) {
            const card = cardsGrid.querySelector(`[data-character="${name}"]`);
            if (gameState.eliminated.has(name)) {
                gameState.eliminated.delete(name);
                card.classList.remove('eliminated');
            } else {
                gameState.eliminated.add(name);
                card.classList.add('eliminated');
            }
        }

        function toggleLLMCardElimination(name) {
            const card = llmCardsGrid.querySelector(`[data-character="${name}"]`);
            if (gameState.llmEliminated.has(name)) {
                gameState.llmEliminated.delete(name);
                card.classList.remove('eliminated');
            } else {
                gameState.llmEliminated.add(name);
                card.classList.add('eliminated');
            }
        }

        // Function for LLM to eliminate characters from its board
        function eliminateCharacter(characterName) {
            // Validate character name exists
            if (!characters.includes(characterName)) {
                console.warn(`Invalid character name: ${characterName}`);
                return { success: false, message: `Character "${characterName}" not found` };
            }

            // Check if already eliminated
            if (gameState.llmEliminated.has(characterName)) {
                return { success: false, message: `Character "${characterName}" is already eliminated` };
            }

            // Eliminate the character from LLM's board
            gameState.llmEliminated.add(characterName);
            const card = llmCardsGrid.querySelector(`[data-character="${characterName}"]`);
            if (card) {
                card.classList.add('eliminated');
            }

            console.log(`LLM eliminated character: ${characterName}`);
            return { success: true, message: `Successfully eliminated ${characterName}` };
        }

        function selectRandomCharacters() {
            const shuffledCharacters = shuffleArray([...characters]);
            gameState.userChosenCharacter = shuffledCharacters[0];
            gameState.opponentChosenCharacter = shuffledCharacters[1];
            
            displayChosenCharacters();
        }

        function displayChosenCharacters() {
            // Display user's chosen character
            const userChosenImage = document.getElementById('userChosenImage');
            
            userChosenImage.src = `guess-who-people/${gameState.userChosenCharacter}.png`;
            userChosenImage.alt = gameState.userChosenCharacter;
            
            userChosenImage.onerror = () => {
                userChosenImage.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjE2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGRkIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPk5vIEltYWdlPC90ZXh0Pjwvc3ZnPg==';
            };

            // Opponent's character stays face-down, but we store the name internally
            console.log(`User's character: ${gameState.userChosenCharacter}`);
            console.log(`Opponent's character: ${gameState.opponentChosenCharacter} (hidden)`);
        }

        async function generateInitialGreeting() {
            try {
                // Check if we have a valid provider and API key
                if (!apiKeys[currentProvider]) {
                    console.log('No API key available for initial greeting');
                    showApiKeyModal();
                    return;
                }

                const provider = providers[currentProvider];
                if (!provider) {
                    console.error('Provider not available:', currentProvider);
                    addMessage('Error: AI provider not available. Please check your configuration.', false);
                    return;
                }

                // Create a simple prompt to generate the greeting
                const greetingPrompt = "Generate a brief, friendly greeting message to start a Guess Who game. Tell the user you're ready to play and ask them for their first question. Keep it conversational and under 2 sentences.";
                
                // Create conversation history with system prompt and greeting request
                const conversationHistory = [{
                    role: 'system',
                    content: GAME_SYSTEM_PROMPT
                }, {
                    role: 'user',
                    content: greetingPrompt
                }];

                console.log('Generating initial greeting (canary test)...');
                
                // Show typing indicator
                const typingIndicator = showTypingIndicator();

                try {
                    const response = await provider.callAPI(greetingPrompt, currentModel, conversationHistory);
                    
                    // Remove typing indicator
                    if (typingIndicator && typingIndicator.parentNode) {
                        typingIndicator.remove();
                    }
                    
                    // Create message element and stream the response
                    const greetingMessageElement = document.createElement('div');
                    greetingMessageElement.className = 'message gpt-message';
                    greetingMessageElement.textContent = '';
                    chatMessages.appendChild(greetingMessageElement);

                    const result = await provider.streamResponse(response, greetingMessageElement);
                    console.log('Initial greeting generated successfully (canary passed)');
                    
                } catch (error) {
                    console.error('Canary test failed - could not generate initial greeting:', error);
                    
                    // Remove typing indicator if still present
                    if (typingIndicator && typingIndicator.parentNode) {
                        typingIndicator.remove();
                    }
                    
                    // Show error message and prompt for API key setup
                    addMessage(`Unable to connect to AI service: ${error.message}`, false);
                    
                    if (error.message.includes('Invalid API key')) {
                        apiKeys[currentProvider] = null;
                        localStorage.removeItem(`${currentProvider}-api-key`);
                        updateApiKeyStatus();
                        showApiKeyModal();
                    }
                }

            } catch (error) {
                console.error('Error in generateInitialGreeting:', error);
                addMessage('Error starting the game. Please check your AI configuration.', false);
            }
        }

        async function loadGameBoard() {
            try {
                // Reset game state
                isFirstGameMessage = true;
                conversationHistory = [];
                
                // Select random characters for user and opponent
                selectRandomCharacters();
                
                // Shuffle the characters for random order (same order for both boards)
                gameState.characters = shuffleArray(characters);
                gameState.eliminated.clear();
                gameState.llmEliminated.clear();

                // Clear existing cards
                cardsGrid.innerHTML = '';
                llmCardsGrid.innerHTML = '';

                // Create and add character cards for both boards
                gameState.characters.forEach(name => {
                    // User's board
                    const userCard = createCharacterCard(name);
                    cardsGrid.appendChild(userCard);
                    
                    // LLM's board
                    const llmCard = createLLMCharacterCard(name);
                    llmCardsGrid.appendChild(llmCard);
                });

                // Clear chat messages for new game
                chatMessages.innerHTML = '';

                // Generate initial LLM greeting message as a "canary" test
                await generateInitialGreeting();

                // Show both grids and hide loading
                loadingBoard.style.display = 'none';
                cardsGrid.style.display = 'grid';
                loadingLLMBoard.style.display = 'none';
                llmCardsGrid.style.display = 'grid';

            } catch (error) {
                console.error('Error loading game board:', error);
                loadingBoard.textContent = 'Error loading characters. Please refresh to try again.';
                loadingLLMBoard.textContent = 'Error loading AI board. Please refresh to try again.';
            }
        }

        function setupPasswordToggle() {
            document.querySelectorAll('.toggle-password').forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const input = toggle.previousElementSibling;
                    if (input.type === 'password') {
                        input.type = 'text';
                        toggle.textContent = 'üôà';
                    } else {
                        input.type = 'password';
                        toggle.textContent = 'üëÅÔ∏è';
                    }
                });
            });
        }

        // Initialize the app
        async function initializeApp() {
            // Load default system prompt first
            await loadDefaultSystemPrompt();
            
            updateApiKeyStatus();
            updateModelIndicator();
            updateKeyStatusIndicators();
            
            // Load the game board
            loadGameBoard();
            setupPasswordToggle();

            if (!apiKeys[currentProvider]) {
                showApiKeyModal();
            }
        }
        
        // Start the app
        initializeApp();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guess Who</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üßë</text></svg>">
    <link rel="stylesheet" href="style.css"> 
    <script src="openai.js"></script>
    <script src="anthropic.js"></script>
    <script src="gemini.js"></script>
</head>
<body>
    <header>
        <h1>Play "Guess Who" with LLMs!</h1>
    </header>

    <!-- Tabbed Game Container -->
    <div class="game-container">
        <div class="tab-navigation">
            <button class="tab-button" onclick="switchTab('user-board')">Your Board</button>
            <button class="tab-button active" onclick="switchTab('chat')">Chat</button>
            <button class="tab-button" onclick="switchTab('llm-board')">AI's Board</button>
        </div>
        
        <div class="tab-content">
            <!-- User's Board Tab -->
            <div class="tab-panel" id="user-board">
                <div class="board">
                    <div class="loading-board" id="loadingBoard">
                        Loading characters...
                    </div>
                    <div class="board-content" id="userBoardContent" style="display: none;">
                        <div class="selected-character-row">
                            <div class="selected-character-container" id="userSelectedContainer">
                                <!-- User's selected character will appear here -->
                            </div>
                        </div>
                        <div class="cards-grid" id="cardsGrid">
                            <!-- Character cards will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- LLM's Board Tab -->
            <div class="tab-panel" id="llm-board">
                <div class="llm-board">
                    <div class="loading-llm-board" id="loadingLLMBoard">
                        Loading AI board...
                    </div>
                    <div class="llm-board-content" id="llmBoardContent" style="display: none;">
                        <div class="selected-character-row">
                            <div class="selected-character-container" id="llmSelectedContainer">
                                <!-- AI's selected character will appear here -->
                            </div>
                        </div>
                        <div class="cards-grid" id="llmCardsGrid">
                            <!-- LLM character cards will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Chat Tab -->
            <div class="tab-panel active" id="chat">
                <div class="chat-container">
                    <div class="model-indicator-bar">
                        <span style="text-align: center;">Playing against:</span>
                        <span class="current-model" id="chatModelIndicator">...</span>
                        <button class="settings-button" onclick="showSettings()">Settings</button>
                    </div>
                    <div class="chat-messages" id="chatMessages">
                        <!-- Chat messages will appear here -->
                    </div>
                    <div class="chat-input" id="chatInputContainer" style="display: none;">
                        <input type="text" id="chatInput" placeholder="Type your message..." onkeypress="handleKeyPress(event)">
                        <button onclick="sendMessage()">Send</button>
                    </div>
                    <div class="start-game-container" id="startGameContainer">
                        <button class="start-game-button" onclick="startGame()">Start!</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- API Key Modal -->
    <div id="apiKeyModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Model Settings</h2>
                <button class="close-modal" onclick="closeModal()">&times;</button>
            </div>
            <div id="modalMessage"></div>            
            <div class="provider-selection">
                <div class="provider-option active" id="openaiProvider" onclick="selectProvider('openai')">
                    <div class="key-status" id="openaiKeyStatus"></div>
                    <strong>OpenAI</strong><br>
                </div>
                <div class="provider-option" id="anthropicProvider" onclick="selectProvider('anthropic')">
                    <div class="key-status" id="anthropicKeyStatus"></div>
                    <strong>Anthropic</strong><br>
                </div>
                <div class="provider-option" id="geminiProvider" onclick="selectProvider('gemini')">
                    <div class="key-status" id="geminiKeyStatus"></div>
                    <strong>Gemini</strong><br>
                </div>
            </div>
            
            <div class="model-selection">
                <label for="modelInput">Model Name (examples: <span id="modelNameExamples"></span>):</label>
                <input type="text" id="modelInput" placeholder="..." oninput="updateSelectedModel()">
                <div class="key-status-text" id="modelStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section current" id="openaiSection">
                <label for="openaiEndpointInput">API Endpoint:</label>
                <div class="key-input-group">
                    <input type="text" id="openaiEndpointInput" placeholder="https://api.openai.com/v1" oninput="saveEndpointToStorage()" />
                </div>
                <label style="margin-top:0.5rem;" for="openaiKeyInput">API Key:</label>
                <div class="key-input-wrapper">
                    <input type="password" id="openaiKeyInput" placeholder="sk-..." oninput="saveApiKeyToStorage('openai')" />
                    <span class="toggle-password">üëÅÔ∏è</span>
                </div>
                <div class="key-status-text" id="openaiKeyStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section" id="anthropicSection">
                <label for="anthropicKeyInput">API Key:</label>
                <div class="key-input-wrapper">
                    <input type="password" id="anthropicKeyInput" placeholder="sk-ant-..." oninput="saveApiKeyToStorage('anthropic')" />
                    <span class="toggle-password">üëÅÔ∏è</span>
                </div>
                <div class="key-status-text" id="anthropicKeyStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section" id="geminiSection">
                <label for="geminiKeyInput">API Key:</label>
                <div class="key-input-wrapper">
                    <input type="password" id="geminiKeyInput" placeholder="AIza..." oninput="saveApiKeyToStorage('gemini')" />
                    <span class="toggle-password">üëÅÔ∏è</span>
                </div>
                <div class="key-status-text" id="geminiKeyStatusText" style="display: none;"></div>
            </div>

            <details>
                <summary>Advanced</summary>
                
                <!-- Game Options Section -->
                <div class="game-options-section">
                    <h3>Game Options</h3>
                    <div class="option-item">
                        <label class="toggle-label">
                            <input type="checkbox" id="showLLMCharacter" onchange="toggleLLMCharacterVisibility()">
                            <span class="toggle-slider"></span>
                            Uncover AI's selected character
                        </label>
                        <p class="option-description">Flip the AI's character card to reveal its identity. It's <i>technically</i> cheating, but it's useful to make sure the LLM is not lying to you üòâ</p>
                    </div>
                </div>
                
                <!-- System Prompt Section -->
                <div class="system-prompt-section">
                    <h3>System Prompt</h3>
                    <p>Customize how the AI behaves in the game. This controls the AI's personality, knowledge, and gameplay style.</p>
                    <textarea id="systemPromptTextarea" class="system-prompt-textarea" placeholder="Enter your system prompt here..."></textarea>
                    <div class="system-prompt-actions">
                        <button class="load-prompt-btn" onclick="loadSimplePrompt()">Load Simple Prompt</button>
                        <button class="load-prompt-btn" onclick="loadSpelledOutPrompt()">Load Spelled Out Prompt</button>
                        <button class="reset-prompt-btn" onclick="resetSystemPrompt()">Reset to Default</button>
                    </div>
                </div>
            </details>

            <div style="display: flex; gap: 0.5rem; margin-top: 1.5rem;">
                <button onclick="testConfiguration()" style="background: linear-gradient(135deg, #88ff00 0%, #1df500 100%); color: white;">Test</button>
                <button onclick="saveConfiguration()" id="saveButton">Save</button>
                <button onclick="closeModal()">Cancel</button>
            </div>
            
        </div>
    </div>

    <script>
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.querySelector('.chat-input button');
        const apiKeyModal = document.getElementById('apiKeyModal');
        const modalMessage = document.getElementById('modalMessage');
        const saveButton = document.getElementById('saveButton');
        const modelInput = document.getElementById('modelInput');
        const modelStatusText = document.getElementById('modelStatusText');
        const modelNameExamples = document.getElementById('modelNameExamples');
        const chatModelIndicator = document.getElementById('chatModelIndicator');
        const openaiProvider = document.getElementById('openaiProvider');
        const anthropicProvider = document.getElementById('anthropicProvider');
        const geminiProvider = document.getElementById('geminiProvider');
        
        // New elements for multi-key support
        const openaiKeyInput = document.getElementById('openaiKeyInput');
        const openaiEndpointInput = document.getElementById('openaiEndpointInput');
        const anthropicKeyInput = document.getElementById('anthropicKeyInput');
        const geminiKeyInput = document.getElementById('geminiKeyInput');
        const openaiKeyStatus = document.getElementById('openaiKeyStatus');
        const anthropicKeyStatus = document.getElementById('anthropicKeyStatus');
        const geminiKeyStatus = document.getElementById('geminiKeyStatus');
        const openaiSection = document.getElementById('openaiSection');
        const anthropicSection = document.getElementById('anthropicSection');
        const geminiSection = document.getElementById('geminiSection');
        const openaiKeyStatusText = document.getElementById('openaiKeyStatusText');
        const anthropicKeyStatusText = document.getElementById('anthropicKeyStatusText');
        const geminiKeyStatusText = document.getElementById('geminiKeyStatusText');
        
        // Game board elements
        const loadingBoard = document.getElementById('loadingBoard');
        const cardsGrid = document.getElementById('cardsGrid');
        const loadingLLMBoard = document.getElementById('loadingLLMBoard');
        const llmCardsGrid = document.getElementById('llmCardsGrid');
        const systemPromptTextarea = document.getElementById('systemPromptTextarea');

        // Default game system prompt (loaded from file)
        let DEFAULT_GAME_SYSTEM_PROMPT = '';

        // Current system prompt (editable)
        let GAME_SYSTEM_PROMPT = localStorage.getItem('custom-system-prompt') || DEFAULT_GAME_SYSTEM_PROMPT;
        
        // Game options
        let showLLMCharacter = localStorage.getItem('show-llm-character') === 'true';

        // Load default system prompt from file
        async function loadDefaultSystemPrompt() {
            try {
                const response = await fetch('prompts/simple.txt');
                if (response.ok) {
                    DEFAULT_GAME_SYSTEM_PROMPT = await response.text();
                    // Update GAME_SYSTEM_PROMPT if no custom prompt is set
                    if (!localStorage.getItem('custom-system-prompt')) {
                        GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                    }
                } else {
                    console.warn('Could not load default system prompt file');
                    // Fallback to a basic prompt
                    DEFAULT_GAME_SYSTEM_PROMPT = 'You are an AI assistant playing "Guess Who" with the user.';
                    if (!localStorage.getItem('custom-system-prompt')) {
                        GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                    }
                }
            } catch (error) {
                console.error('Error loading default system prompt:', error);
                // Fallback to a basic prompt
                DEFAULT_GAME_SYSTEM_PROMPT = 'You are an AI assistant playing "Guess Who" with the user.';
                if (!localStorage.getItem('custom-system-prompt')) {
                    GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                }
            }
        }

        // Configuration storage
        let currentProvider = localStorage.getItem('ai-provider') || '';
        let currentModel = localStorage.getItem('ai-model') || '';
        let apiKeys = {
            openai: localStorage.getItem('openai-api-key'),
            anthropic: localStorage.getItem('anthropic-api-key'),
            gemini: localStorage.getItem('gemini-api-key'),
        };
        let isProcessing = false;

        // Character data
        const characters = [
            'Abigail', 'Alex', 'Alice', 'Amy', 'Andy', 'Ashley', 'Brandon', 'Brian',
            'Daniel', 'David', 'Emily', 'Henry', 'Jake', 'James', 'Joe', 'Jon',
            'Joseph', 'Joshua', 'Justin', 'Kyle', 'Matt', 'Megan', 'Melissa',
            'Nick', 'Peter', 'Rachael', 'Tyler', 'William'
        ];

        let gameState = {
            characters: [],
            eliminated: new Set(),
            llmEliminated: new Set(),
            userChosenCharacter: null,
            opponentChosenCharacter: null
        };

        // Initialize AI providers
        const providers = {
            openai: new OpenAIProvider(),
            anthropic: new AnthropicProvider(),
            gemini: new GeminiProvider(),
        };

        function updateKeyStatusIndicators() {
            // Update OpenAI key status indicator
            if (apiKeys.openai) {
                openaiKeyStatus.classList.add('has-key');
            } else {
                openaiKeyStatus.classList.remove('has-key');
            }

            // Update Anthropic key status indicator
            if (apiKeys.anthropic) {
                anthropicKeyStatus.classList.add('has-key');
            } else {
                anthropicKeyStatus.classList.remove('has-key');
            }

            // Update Gemini key status indicator
            if (apiKeys.gemini) {
                geminiKeyStatus.classList.add('has-key');
            } else {
                geminiKeyStatus.classList.remove('has-key');
            }
        }

        function updateModelIndicator() {
            if (chatModelIndicator) {
                chatModelIndicator.textContent = currentModel;
            }
        }

        function selectProvider(provider) {
            currentProvider = provider;
            
            // Update provider selection UI
            openaiProvider.classList.remove('active');
            anthropicProvider.classList.remove('active');
            geminiProvider.classList.remove('active');
            document.getElementById(provider + 'Provider').classList.add('active');
            
            // Update section highlighting
            openaiSection.classList.remove('current');
            anthropicSection.classList.remove('current');
            geminiSection.classList.remove('current');
            document.getElementById(provider + 'Section').classList.add('current');
            
            // Update model input
            updateModelInput();
            updateModelIndicator();
        }

        function updateModelInput() {
            const provider = providers[currentProvider];
            
            // Update the examples span with provider's example models
            modelNameExamples.textContent = provider.exampleModels || 'No examples available';
            
            // Clear the model field when switching providers
            currentModel = localStorage.getItem(`${currentProvider}-ai-model`) || '';
            modelInput.value = currentModel;
            
            // Clear any previous validation status
            modelStatusText.style.display = 'none';
        }

        function updateSelectedModel() {
            const newModel = modelInput.value.trim();
            currentModel = newModel;
            // Update the model indicator
            updateModelIndicator();
            // Save the new model selection
            localStorage.setItem('ai-model', currentModel);
            localStorage.setItem(`${currentProvider}-ai-model`, currentModel);
            // Clear any previous validation status when model changes
            modelStatusText.style.display = 'none';
        }
        
        async function testConfiguration() {
            // Clear previous messages
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
            
            // Get current configuration
            const modelName = modelInput.value.trim();
            const provider = providers[currentProvider];
            
            // Validate required fields based on provider
            let missingFields = [];
            
            // Check model name
            if (!modelName) {
                missingFields.push('Model Name');
            }
            
            // Check API key
            let apiKey = '';
            if (currentProvider === 'openai') {
                apiKey = openaiKeyInput.value.trim();
                if (!apiKey) {
                    missingFields.push('API Key');
                }
                const endpoint = openaiEndpointInput.value.trim();
                if (!endpoint) {
                    missingFields.push('API Endpoint');
                }
            } else if (currentProvider === 'anthropic') {
                apiKey = anthropicKeyInput.value.trim();
                if (!apiKey) {
                    missingFields.push('API Key');
                }
            } else if (currentProvider === 'gemini') {
                apiKey = geminiKeyInput.value.trim();
                if (!apiKey) {
                    missingFields.push('API Key');
                }
            }
            
            // Show error if any fields are missing
            if (missingFields.length > 0) {
                showModalMessage(`Missing required fields: ${missingFields.join(', ')}`, true);
                return;
            }
            
            // Show testing status
            showModalMessage('Testing configuration...', false);
            
            try {
                // Test the complete configuration
                await provider.validateApiKey(apiKey, modelName);
                showModalMessage('‚úÖ Configuration is valid and working!', false);
            } catch (error) {
                console.error('Configuration test failed:', error);
                showModalMessage(`‚ùå Configuration test failed: ${error.message}`, true);
            }
        }
        
        function showModelStatus(message, status) {
            modelStatusText.textContent = message;
            modelStatusText.className = `key-status-text ${status}`;
            modelStatusText.style.display = 'block';
        }
        
        function saveEndpointToStorage() {
            const endpoint = openaiEndpointInput.value.trim();
            if (endpoint) {
                localStorage.setItem('openai-endpoint', endpoint);
            } else {
                localStorage.removeItem('openai-endpoint');
            }
        }
        
        function saveApiKeyToStorage(provider) {
            let keyInput, storageKey;
            
            if (provider === 'openai') {
                keyInput = openaiKeyInput;
                storageKey = 'openai-api-key';
            } else if (provider === 'anthropic') {
                keyInput = anthropicKeyInput;
                storageKey = 'anthropic-api-key';
            } else if (provider === 'gemini') {
                keyInput = geminiKeyInput;
                storageKey = 'gemini-api-key';
            }
            
            const key = keyInput.value.trim();
            if (key) {
                localStorage.setItem(storageKey, key);
                apiKeys[provider] = key;
            } else {
                localStorage.removeItem(storageKey);
                apiKeys[provider] = null;
            }
            
            // Update key status indicators
            updateKeyStatusIndicators();
        }
        
        function showSettings() {
            // Set up the modal with current configuration
            selectProvider(currentProvider || 'openai');
            modelInput.value = localStorage.getItem(`${currentProvider}-ai-model`) || '';;
            
            // Populate existing API keys and endpoint
            if (apiKeys.openai) {
                openaiKeyInput.value = apiKeys.openai;
            }
            // Populate OpenAI endpoint
            const savedEndpoint = localStorage.getItem('openai-endpoint');
            if (savedEndpoint) {
                openaiEndpointInput.value = savedEndpoint;
            } else {
                openaiEndpointInput.value = providers.openai.defaultEndpoint;
            }
            if (apiKeys.anthropic) {
                anthropicKeyInput.value = apiKeys.anthropic;
            }
            if (apiKeys.gemini) {
                geminiKeyInput.value = apiKeys.gemini;
            }
            // Populate system prompt textarea
            systemPromptTextarea.value = GAME_SYSTEM_PROMPT;
            
            // Set checkbox state for LLM character visibility
            document.getElementById('showLLMCharacter').checked = showLLMCharacter;
            
            // Update key status indicators
            updateKeyStatusIndicators();
            
            // Clear any previous messages
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
            
            apiKeyModal.style.display = 'block';
        }

        function showModalMessage(message, isError = false) {
            modalMessage.innerHTML = `<div class="${isError ? 'error-message' : 'success-message'}">${message}</div>`;
        }

        function closeModal() {
            apiKeyModal.style.display = 'none';
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
        }

        function clearAllKeyStatusTexts() {
            openaiKeyStatusText.style.display = 'none';
            anthropicKeyStatusText.style.display = 'none';
            geminiKeyStatusText.style.display = 'none';
        }

        function showKeyStatus(provider, message, status) {
            let statusElement;
            if (provider === 'openai') {
                statusElement = openaiKeyStatusText;
            } else if (provider === 'anthropic') {
                statusElement = anthropicKeyStatusText;
            } else if (provider === 'gemini') {
                statusElement = geminiKeyStatusText;
            }
            statusElement.textContent = message;
            statusElement.className = `key-status-text ${status}`;
            statusElement.style.display = 'block';
        }

        async function saveConfiguration() {
            const openaiKey = openaiKeyInput.value.trim();
            const anthropicKey = anthropicKeyInput.value.trim();
            const geminiKey = geminiKeyInput.value.trim();
            
            // Validate that the selected provider has a key
            let selectedProviderKey;
            if (currentProvider === 'openai') {
                selectedProviderKey = openaiKey;
            } else if (currentProvider === 'anthropic') {
                selectedProviderKey = anthropicKey;
            } else if (currentProvider === 'gemini') {
                selectedProviderKey = geminiKey;
            }

            if (!selectedProviderKey) {
                showModalMessage(`Please enter an API key for ${currentProvider.charAt(0).toUpperCase() + currentProvider.slice(1)} to use this provider.`, true);
                return;
            }

            saveButton.disabled = true;

            try {
                // Save OpenAI key if provided
                if (openaiKey) {
                    apiKeys.openai = openaiKey;
                    localStorage.setItem('openai-api-key', openaiKey);
                } else if (apiKeys.openai) {
                    // Keep existing key if no new one provided
                    openaiKeyInput.value = apiKeys.openai;
                }
                
                // Save OpenAI endpoint
                if (openaiEndpointInput) {
                    providers.openai.setEndpoint(openaiEndpointInput.value);
                } else {
                    // Use default endpoint if empty
                    providers.openai.setEndpoint(providers.openai.defaultEndpoint);
                    openaiEndpointInput.value = providers.openai.defaultEndpoint;
                }

                // Save Anthropic key if provided
                if (anthropicKey) {
                    apiKeys.anthropic = anthropicKey;
                    localStorage.setItem('anthropic-api-key', anthropicKey);
                } else if (apiKeys.anthropic) {
                    // Keep existing key if no new one provided
                    anthropicKeyInput.value = apiKeys.anthropic;
                }

                // Save Gemini key if provided
                if (geminiKey) {
                    apiKeys.gemini = geminiKey;
                    localStorage.setItem('gemini-api-key', geminiKey);
                } else if (apiKeys.gemini) {
                    // Keep existing key if no new one provided
                    geminiKeyInput.value = apiKeys.gemini;
                }

                // Save system prompt
                const newPrompt = systemPromptTextarea.value.trim();
                if (newPrompt) {
                    GAME_SYSTEM_PROMPT = newPrompt;
                    localStorage.setItem('custom-system-prompt', newPrompt);
                } else {
                    GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                    localStorage.removeItem('custom-system-prompt');
                }

                // Save current provider and model
                const changedProvider = localStorage.getItem('ai-provider') !== currentProvider;
                localStorage.setItem('ai-provider', currentProvider);

                // Update UI
                updateModelIndicator();
                updateKeyStatusIndicators();

                // Close modal after delay
                setTimeout(() => {
                    closeModal();
                }, 500);

                // Reload the page if the provider was changed
                if (changedProvider) {
                    location.reload();
                }

            } catch (error) {
                showModalMessage(error.message, true);
            } finally {
                saveButton.disabled = false;
            }
        }


        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        function addMessage(content, isUser = false) {
            const messageElement = document.createElement('div');
            messageElement.className = `message ${isUser ? 'user-message' : 'gpt-message'}`;
            messageElement.textContent = content;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function showTypingIndicator() {
            const typingElement = document.createElement('div');
            typingElement.className = 'typing-indicator';
            typingElement.innerHTML = `
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            `;
            chatMessages.appendChild(typingElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            return typingElement;
        }

        function setProcessingState(processing) {
            isProcessing = processing;
            if (sendButton) {
                sendButton.disabled = processing;
            }
            if (chatInput) {
                chatInput.disabled = processing;
            }
        }

        // Function definitions for AI tools
        const ELIMINATE_CHARACTER_FUNCTION = {
            name: 'eliminateCharacter',
            description: 'Eliminate a character from your board when you learn they cannot be the user\'s character',
            parameters: {
                type: 'object',
                properties: {
                    characterName: {
                        type: 'string',
                        description: 'The exact name of the character to eliminate from the board',
                        enum: characters
                    }
                },
                required: ['characterName']
            }
        };

        const END_GAME_FUNCTION = {
            name: 'endGame',
            description: 'When you or the the user guesses correctly, the game should end.',
            parameters: {
                type: 'object',
                properties: {
                    winner: {
                        type: 'string',
                        description: 'either you (llm) or the user',
                        enum: ['llm', 'user']
                    }},
                required: ['winner']
            }
        };

        async function callAI(message) {
            console.log('callAI called with:', { message, currentProvider, hasApiKey: !!apiKeys[currentProvider] });
            
            if (!apiKeys[currentProvider]) {
                console.log('No API key found, showing modal');
                showSettings();
                return;
            }

            setProcessingState(true);
            const typingIndicator = showTypingIndicator();

            try {
                const provider = providers[currentProvider];
                if (!provider) {
                    throw new Error('Unsupported provider: ' + currentProvider);
                }
                
                console.log('Calling API for provider:', currentProvider);
                                
                const multimodalMessage = await provider.createMultimodalMessage(message);
                const response = await provider.callAPI(multimodalMessage, currentModel, [ELIMINATE_CHARACTER_FUNCTION, END_GAME_FUNCTION]);

                console.log('API response received, status:', response.status);

                // Stream the response - message element will be created when typing indicator is removed
                const result = await provider.streamResponse(response, null, typingIndicator);
                const aiResponse = result.response;
                const hasToolCalls = result.hasToolCalls;
                const toolCalls = result.toolCalls || [];
                
                // Execute tool calls if any
                if (toolCalls.length > 0) {
                    console.log('Executing tool calls:', toolCalls);
                    for (const toolCall of toolCalls) {
                        if (toolCall.function.name === 'eliminateCharacter') {
                            try {
                                const args = JSON.parse(toolCall.function.arguments);
                                const functionResult = eliminateCharacter(args.characterName);
                                console.log('Tool call result:', functionResult);
                                
                                // Display the elimination in the chat
                                if (functionResult.success) {
                                    const eliminationDiv = document.createElement('div');
                                    eliminationDiv.className = 'elimination-notice';
                                    eliminationDiv.textContent = `üö´ Eliminated: ${args.characterName}`;
                                    eliminationDiv.style.cssText = `
                                        background: rgba(255, 0, 0, 0.1);
                                        border-left: 3px solid #ff0000;
                                        padding: 8px 12px;
                                        margin: 4px 0;
                                        font-size: 0.9em;
                                        color: #666;
                                    `;
                                    chatMessages.appendChild(eliminationDiv);
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                }
                            } catch (e) {
                                console.error('Error executing tool call:', e);
                            }
                        } else if (toolCall.function.name === 'endGame') {
                            const args = JSON.parse(toolCall.function.arguments);
                            console.log("parsing arguments", args);
                            // Create confetti effect and congratulations popup
                            createConfetti();
                            showCongratulationsPopup(args.winner);
                        }
                    }
                }

            } catch (error) {
                console.error('Error calling AI API:', error);
                
                // Remove typing indicator if still present
                if (typingIndicator && typingIndicator.parentNode) {
                    typingIndicator.remove();
                }
                
                // Create error message element
                const errorElement = document.createElement('div');
                errorElement.className = 'message gpt-message';
                errorElement.textContent = `Error: ${error.message}`;
                chatMessages.appendChild(errorElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                if (error.message.includes('Invalid API key')) {
                    apiKeys[currentProvider] = null;
                    localStorage.removeItem(`${currentProvider}-api-key`);
                    showSettings();
                }
            } finally {
                setProcessingState(false);
            }
        }

        function sendMessage() {
            const message = chatInput.value.trim();
            if (message && !isProcessing) {
                console.log('Sending message:', message);
                console.log('Current provider:', currentProvider);
                console.log('Has API key:', !!apiKeys[currentProvider]);
                
                addMessage(message, true);
                
                chatInput.value = '';
                callAI(message);
            } else {
                console.log('Message not sent - empty or processing:', { message: !!message, isProcessing });
            }
        }

        window.onclick = function(event) {
            if (event.target === apiKeyModal) {
                closeModal();
            }
        }

        function resetSystemPrompt() {
            if (confirm('Are you sure you want to reset to the default system prompt? This will overwrite your current customizations.')) {
                GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                systemPromptTextarea.value = DEFAULT_GAME_SYSTEM_PROMPT;
                localStorage.removeItem('custom-system-prompt');
                
                // Show success feedback
                const resetButton = document.querySelector('.reset-prompt-btn');
                const originalText = resetButton.textContent;
                resetButton.textContent = 'Reset ‚úì';
                
                setTimeout(() => {
                    resetButton.textContent = originalText;
                }, 1000);
                
                console.log('System prompt reset to default');
            }
        }

        // Load simple prompt
        async function loadSimplePrompt() {
            try {
                const response = await fetch('prompts/simple.txt');
                if (response.ok) {
                    const promptText = await response.text();
                    systemPromptTextarea.value = promptText;
                    console.log('Simple prompt loaded');
                } else {
                    throw new Error(`Failed to load simple prompt: ${response.status}`);
                }
            } catch (error) {
                console.error('Error loading simple prompt:', error);
                alert('Failed to load simple prompt. Please check if the file exists.');
            }
        }

        // Load spelled-out prompt
        async function loadSpelledOutPrompt() {
            try {
                const response = await fetch('prompts/spelled-out.txt');
                if (response.ok) {
                    const promptText = await response.text();
                    systemPromptTextarea.value = promptText;
                    console.log('Spelled out prompt loaded');
                } else {
                    throw new Error(`Failed to load spelled out prompt: ${response.status}`);
                }
            } catch (error) {
                console.error('Error loading spelled out prompt:', error);
                alert('Failed to load spelled out prompt. Please check if the file exists.');
            }
        }

        // Game functions
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function createCharacterCard(name) {
            const card = document.createElement('div');
            card.className = 'character-card';
            card.dataset.character = name;
            card.onclick = () => toggleCardElimination(name);

            const img = document.createElement('img');
            img.src = `guess-who-people/${name}.png`;
            img.alt = name;
            img.onerror = () => {
                img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOTAiIGhlaWdodD0iMTIwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiNkZGQiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+Tm8gSW1hZ2U8L3RleHQ+PC9zdmc+';
            };

            card.appendChild(img);

            return card;
        }

        function createLLMCharacterCard(name) {
            const card = document.createElement('div');
            card.className = 'character-card';
            card.dataset.character = name;

            const img = document.createElement('img');
            img.src = `guess-who-people/${name}.png`;
            img.alt = name;
            img.onerror = () => {
                img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzAiIGhlaWdodD0iOTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0iI2RkZCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTAiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
            };

            card.appendChild(img);

            return card;
        }

        function toggleCardElimination(name) {
            const card = cardsGrid.querySelector(`[data-character="${name}"]`);
            if (gameState.eliminated.has(name)) {
                gameState.eliminated.delete(name);
                card.classList.remove('eliminated');
            } else {
                gameState.eliminated.add(name);
                card.classList.add('eliminated');
            }
        }


        // Helper functions for image loading
        async function getImageAsBase64(imageUrl) {
            try {
                const response = await fetch(imageUrl);
                if (!response.ok) {
                    throw new Error(`Failed to load image: ${response.status}`);
                }
                const blob = await response.blob();
                
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function() {
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error(`Failed to load image ${imageUrl}:`, error);
                return null;
            }
        }

        // Function for LLM to eliminate characters from its board
        function eliminateCharacter(characterName) {
            // Validate character name exists
            if (!characters.includes(characterName)) {
                console.warn(`Invalid character name: ${characterName}`);
                return { success: false, message: `Character "${characterName}" not found` };
            }

            // Check if already eliminated
            if (gameState.llmEliminated.has(characterName)) {
                return { success: false, message: `Character "${characterName}" is already eliminated` };
            }

            // Eliminate the character from LLM's board
            gameState.llmEliminated.add(characterName);
            const card = llmCardsGrid.querySelector(`[data-character="${characterName}"]`);
            if (card) {
                card.classList.add('eliminated');
            }

            console.log(`LLM eliminated character: ${characterName}`);
            return { success: true, message: `Successfully eliminated ${characterName}` };
        }

        function selectRandomCharacters() {
            const shuffledCharacters = shuffleArray([...characters]);
            gameState.userChosenCharacter = shuffledCharacters[0];
            gameState.opponentChosenCharacter = shuffledCharacters[1];
            
            console.log(`User's character: ${gameState.userChosenCharacter}`);
            console.log(`Opponent's character: ${gameState.opponentChosenCharacter}`);
        }

        function startGame() {
            // Hide the start game container and show the chat input
            const startGameContainer = document.getElementById('startGameContainer');
            const chatInputContainer = document.getElementById('chatInputContainer');
            
            startGameContainer.style.display = 'none';
            chatInputContainer.style.display = 'flex';
            
            // Generate the initial greeting
            generateInitialGreeting();
        }

        async function generateInitialGreeting() {
            try {
                // Check if we have a valid provider and API key
                if (!apiKeys[currentProvider]) {
                    console.log('No API key available for initial greeting');
                    showSettings();
                    return;
                }

                const provider = providers[currentProvider];
                if (!provider) {
                    console.error('Provider not available:', currentProvider);
                    addMessage('Error: AI provider not available. Please check your configuration.', false);
                    return;
                }

                // Create a simple prompt to generate the greeting
                const greetingPrompt = "Generate a brief, friendly greeting message to start a Guess Who game. Tell the user whether you received the image of the board and your character and ask them for their first question. Keep it conversational and under 2 sentences.";
                
                console.log('Generating initial message...');
                
                // Set system prompt for the provider
                provider.setSystemPrompt(GAME_SYSTEM_PROMPT);

                // Add the board and the selected character to the chat history
                provider.addToHistory(provider.createMultimodalMessage('Here is the board:', await getImageAsBase64('full-board.png')));
                provider.addToHistory(provider.createMultimodalMessage('Here is YOUR character:', await getImageAsBase64(`guess-who-people/${gameState.opponentChosenCharacter}.png`)));
                
                // Show typing indicator and disable send button
                setProcessingState(true);
                const typingIndicator = showTypingIndicator();

                try {
                    const greetingMultimodal = await provider.createMultimodalMessage(greetingPrompt);
                    const response = await provider.callAPI(greetingMultimodal, currentModel, [ELIMINATE_CHARACTER_FUNCTION]);
                    
                    // Stream the response - message element will be created when typing indicator is removed
                    const result = await provider.streamResponse(response, null, typingIndicator);
                    console.log('Initial greeting generated successfully');
                    
                    // Re-enable send button after successful response
                    setProcessingState(false);
                    
                } catch (error) {
                    console.error('Could not generate initial greeting:', error);
                    
                    // Remove typing indicator if still present
                    if (typingIndicator && typingIndicator.parentNode) {
                        typingIndicator.remove();
                    }
                    
                    // Re-enable send button on error
                    setProcessingState(false);
                    
                    // Show error message and prompt for API key setup
                    addMessage(`Unable to connect to AI service: ${error.message}`, false);
                    
                    if (error.message.includes('Invalid API key')) {
                        apiKeys[currentProvider] = null;
                        localStorage.removeItem(`${currentProvider}-api-key`);
                        showSettings();
                    }
                }

            } catch (error) {
                console.error('Error in generateInitialGreeting:', error);
                addMessage('Error starting the game. Please check your AI configuration.', false);
            }
        }

        async function loadGameBoard() {
            try {
                // Reset game state
                isFirstGameMessage = true;
                
                // Clear all provider conversation histories
                Object.values(providers).forEach(provider => {
                    provider.clearHistory();
                });
                
                // Select random characters for user and opponent
                selectRandomCharacters();
                
                // Shuffle all characters for the main grid (including selected ones)
                gameState.characters = shuffleArray(characters);
                gameState.eliminated.clear();
                gameState.llmEliminated.clear();

                // Clear existing cards
                cardsGrid.innerHTML = '';
                llmCardsGrid.innerHTML = '';
                document.getElementById('userSelectedContainer').innerHTML = '';
                document.getElementById('llmSelectedContainer').innerHTML = '';

                // Create selected character cards for top rows
                const userSelectedCard = createCharacterCard(gameState.userChosenCharacter);
                userSelectedCard.classList.add('top-selected-character');
                userSelectedCard.onclick = null; // Remove click functionality for top row
                document.getElementById('userSelectedContainer').appendChild(userSelectedCard);

                const llmSelectedCard = createLLMCharacterCard(gameState.opponentChosenCharacter);
                llmSelectedCard.classList.add('top-selected-character');
                document.getElementById('llmSelectedContainer').appendChild(llmSelectedCard);

                // Create and add all character cards for main grids (including selected characters)
                gameState.characters.forEach(name => {
                    // User's board
                    const userCard = createCharacterCard(name);
                    cardsGrid.appendChild(userCard);
                    
                    // LLM's board
                    const llmCard = createLLMCharacterCard(name);
                    llmCardsGrid.appendChild(llmCard);
                });

                // Clear chat messages for new game
                chatMessages.innerHTML = '';

                // Show both board contents and hide loading
                loadingBoard.style.display = 'none';
                document.getElementById('userBoardContent').style.display = 'block';
                loadingLLMBoard.style.display = 'none';
                document.getElementById('llmBoardContent').style.display = 'block';
                
                // Apply LLM character visibility setting
                updateLLMCharacterVisibility();

            } catch (error) {
                console.error('Error loading game board:', error);
                loadingBoard.textContent = 'Error loading characters. Please refresh to try again.';
                loadingLLMBoard.textContent = 'Error loading AI board. Please refresh to try again.';
            }
        }

        function setupPasswordToggle() {
            document.querySelectorAll('.toggle-password').forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const input = toggle.previousElementSibling;
                    if (input.type === 'password') {
                        input.type = 'text';
                        toggle.textContent = 'üôà';
                    } else {
                        input.type = 'password';
                        toggle.textContent = 'üëÅÔ∏è';
                    }
                });
            });
        }

        // Initialize the app
        async function initializeApp() {
            // Load default system prompt first
            await loadDefaultSystemPrompt();
            
            updateModelIndicator();
            updateKeyStatusIndicators();
            
            // Load the game board
            loadGameBoard();
            setupPasswordToggle();

            if (!currentProvider) {
                showSettings();
            }
            if (!apiKeys[currentProvider]) {
                showSettings();
            }
        }
        
        // Tab switching functionality
        function switchTab(tabName) {
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Remove active class from all tab panels
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Add active class to clicked button
            event.target.classList.add('active');
            
            // Show the selected tab panel
            document.getElementById(tabName).classList.add('active');
        }

        // Toggle LLM character visibility function
        function toggleLLMCharacterVisibility() {
            showLLMCharacter = document.getElementById('showLLMCharacter').checked;
            localStorage.setItem('show-llm-character', showLLMCharacter.toString());
            updateLLMCharacterVisibility();
        }

        // Update LLM character visibility function
        function updateLLMCharacterVisibility() {
            const llmSelectedCard = document.querySelector('#llmSelectedContainer .character-card');
            if (llmSelectedCard) {
                if (showLLMCharacter) {
                    llmSelectedCard.classList.remove('hidden-character');
                } else {
                    llmSelectedCard.classList.add('hidden-character');
                }
            }
        }

        // Confetti effect function
        function createConfetti() {
            const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffd93d', '#ffbe0b'];
            const confettiContainer = document.createElement('div');
            confettiContainer.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 10000;
            `;
            document.body.appendChild(confettiContainer);

            // Create confetti pieces
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                const color = colors[Math.floor(Math.random() * colors.length)];
                const size = Math.random() * 10 + 5;
                const left = Math.random() * 100;
                const animationDuration = Math.random() * 3 + 2;
                const opacity = Math.random() * 0.7 + 0.3;

                confetti.style.cssText = `
                    position: absolute;
                    background-color: ${color};
                    width: ${size}px;
                    height: ${size}px;
                    left: ${left}%;
                    top: -10px;
                    opacity: ${opacity};
                    border-radius: ${Math.random() > 0.5 ? '50%' : '0'};
                    animation: confettiFall ${animationDuration}s linear forwards;
                `;

                confettiContainer.appendChild(confetti);
            }

            // Add confetti animation CSS
            if (!document.querySelector('#confetti-styles')) {
                const style = document.createElement('style');
                style.id = 'confetti-styles';
                style.textContent = `
                    @keyframes confettiFall {
                        0% {
                            transform: translateY(-10px) rotate(0deg);
                        }
                        100% {
                            transform: translateY(100vh) rotate(360deg);
                        }
                    }
                `;
                document.head.appendChild(style);
            }

            // Remove confetti after animation
            setTimeout(() => {
                confettiContainer.remove();
            }, 5000);
        }

        // Congratulations popup function
        function showCongratulationsPopup(winner) {
            // Create popup overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 10001;
                animation: fadeIn 0.3s ease-out;
            `;

            // Create popup content
            const popup = document.createElement('div');
            popup.style.cssText = `
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                color: white;
                padding: 40px;
                border-radius: 20px;
                text-align: center;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
                max-width: 400px;
                animation: popIn 0.4s ease-out;
            `;

            if (winner === 'user') {
                popup.innerHTML = `
                    <div style="font-size: 60px; margin-bottom: 20px;">üéâ</div>
                    <h2 style="margin: 0 0 15px 0; font-size: 28px; font-weight: bold;">Congratulations!</h2>
                    <p style="margin: 0 0 25px 0; font-size: 16px; line-height: 1.4;">You won the game! üèÜ</p>
                    <button id="closePopup" style="
                        background-color: #fff;
                        color: #667eea;
                        border: none;
                        padding: 12px 30px;
                        border-radius: 25px;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        transition: transform 0.2s ease;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        Play Again!
                    </button>
                `;
            } else {
                popup.innerHTML = `
                    <div style="font-size: 60px; margin-bottom: 20px;">‚ò†Ô∏è</div>
                    <h2 style="margin: 0 0 15px 0; font-size: 28px; font-weight: bold;">Try again!</h2>
                    <p style="margin: 0 0 25px 0; font-size: 16px; line-height: 1.4;">You lost this time üò≠</p>
                    <button id="closePopup" style="
                        background-color: #fff;
                        color: #667eea;
                        border: none;
                        padding: 12px 30px;
                        border-radius: 25px;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        transition: transform 0.2s ease;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        Play Again!
                    </button>
                `;
            }
            

            // Add popup animations CSS
            if (!document.querySelector('#popup-styles')) {
                const style = document.createElement('style');
                style.id = 'popup-styles';
                style.textContent = `
                    @keyframes fadeIn {
                        from { opacity: 0; }
                        to { opacity: 1; }
                    }
                    @keyframes popIn {
                        0% {
                            opacity: 0;
                            transform: scale(0.8) translateY(-10px);
                        }
                        100% {
                            opacity: 1;
                            transform: scale(1) translateY(0);
                        }
                    }
                `;
                document.head.appendChild(style);
            }

            overlay.appendChild(popup);
            document.body.appendChild(overlay);

            // Close popup handler
            document.getElementById('closePopup').onclick = () => {
                overlay.style.animation = 'fadeIn 0.3s ease-out reverse';
                setTimeout(() => {
                    overlay.remove();
                    // Reset the game
                    location.reload();
                }, 300);
            };

            // Close on overlay click
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    document.getElementById('closePopup').click();
                }
            };
        }

        // Start the app
        initializeApp();
    </script>
</body>
</html>
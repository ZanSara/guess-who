<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guess Who</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            color: white;
            padding: 1.5rem;
            text-align: center;
            width: 100%;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        header h1 {
            margin: 0;
            font-size: 2rem;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 2rem 0;
            width: 90%;
            max-width: 800px;
        }
        
        .chosen-characters {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 2rem;
            gap: 2rem;
        }
        
        .chosen-character {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            text-align: center;
        }
        
        .chosen-character h3 {
            margin: 0 0 1rem 0;
            color: #333;
            font-size: 1.25rem;
            font-weight: 600;
        }
        
        .chosen-card {
            width: 120px;
            height: 160px;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2);
            margin: 0 auto;
            position: relative;
            background: white;
            transition: all 0.3s ease;
        }
        
        .chosen-card:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
        }
        
        .chosen-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
        }
        
        .chosen-card.face-down {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .chosen-card.face-down::before {
            content: '?';
        }
        
        
        .board {
            width: 100%;
            min-height: 500px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            margin-bottom: 2rem;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(4px);
            padding: 1rem;
        }
        
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 0.5rem 0.5rem;
            justify-items: center;
            align-items: center;
            max-width: 100%;
        }
        
        .character-card {
            width: 90px;
            height: 120px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            background: white;
        }
        
        .character-card:hover {
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        
        .character-card.eliminated {
            opacity: 0.3;
            filter: grayscale(100%);
            transform: scale(0.9);
        }
        
        .character-card.eliminated:hover {
            transform: scale(0.95);
        }

        .llm-board {
            width: 100%;
            min-height: 400px;
            background: linear-gradient(135deg, #e8f5e8 0%, #d4e6d4 100%);
            margin-top: 2rem;
            border-radius: 15px;
            border: 1px solid rgba(76, 175, 80, 0.3);
            box-shadow: 0 8px 32px rgba(76, 175, 80, 0.15);
            backdrop-filter: blur(4px);
            padding: 1rem;
        }

        .llm-board-header {
            text-align: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid rgba(76, 175, 80, 0.2);
        }

        .llm-board-header h3 {
            margin: 0;
            color: #2e7d32;
            font-size: 1.5rem;
            font-weight: 600;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .llm-board-header p {
            margin: 0.5rem 0 0 0;
            color: #4caf50;
            font-size: 0.9rem;
            font-style: italic;
        }

        .system-prompt-button {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(255, 152, 0, 0.3);
            transition: all 0.3s ease;
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .system-prompt-button:hover {
            transform: translateY(-3px) scale(1.1);
            box-shadow: 0 8px 25px rgba(255, 152, 0, 0.4);
        }

        .system-prompt-button:active {
            transform: translateY(-1px);
        }

        .system-prompt-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
            animation: fadeIn 0.3s ease;
        }

        .system-prompt-modal-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
            animation: slideIn 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .system-prompt-modal h2 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: #333;
            font-size: 1.8rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .system-prompt-modal h2::before {
            content: '‚öôÔ∏è';
            font-size: 1.5rem;
        }

        .system-prompt-textarea {
            width: 100%;
            height: 400px;
            padding: 1rem;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            resize: vertical;
            outline: none;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.8);
            margin-bottom: 1.5rem;
        }

        .system-prompt-textarea:focus {
            border-color: #ff9800;
            box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.1);
            background: white;
        }

        .system-prompt-actions {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .system-prompt-actions button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 120px;
        }

        .save-prompt-btn {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }

        .save-prompt-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }

        .reset-prompt-btn {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
        }

        .reset-prompt-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 152, 0, 0.4);
        }

        .cancel-prompt-btn {
            background: #6c757d;
            color: white;
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
        }

        .cancel-prompt-btn:hover {
            background: #545b62;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(108, 117, 125, 0.4);
        }

        .llm-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 0.4rem 0.4rem;
            justify-items: center;
            align-items: center;
            max-width: 100%;
        }

        .llm-character-card {
            width: 70px;
            height: 93px;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.2);
            transition: all 0.3s ease;
            position: relative;
            background: white;
            border: 2px solid transparent;
        }

        .llm-character-card:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.3);
            border-color: #4caf50;
        }

        .llm-character-card.eliminated {
            opacity: 0.2;
            filter: grayscale(100%) brightness(0.7);
            transform: scale(0.85);
            border-color: #ff5722;
        }

        .llm-character-card.eliminated:hover {
            transform: scale(0.9);
            border-color: #ff5722;
        }

        .llm-character-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
        }

        .loading-llm-board {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 300px;
            font-size: 1.1rem;
            color: #4caf50;
            font-weight: 500;
        }
        
        .character-card img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
        }
        
        .loading-board {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 500px;
            font-size: 1.2rem;
            color: #666;
            font-weight: 500;
        }
        
        @media (max-width: 768px) {
            .cards-grid {
                grid-template-columns: repeat(auto-fill, minmax(75px, 1fr));
                gap: 0.25rem 0.25rem;
            }
            
            .character-card {
                width: 75px;
                height: 100px;
            }
        }
        
        .chat-container {
            width: 100%;
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .chat-messages {
            height: 300px;
            overflow-y: auto;
            margin-bottom: 1.5rem;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            padding: 1rem;
            background: #fafafa;
            scrollbar-width: thin;
            scrollbar-color: #cbd5e0 transparent;
            display: flex;
            flex-direction: column;
        }
        
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }
        
        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .chat-messages::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 3px;
        }
        
        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }
        
        .chat-input {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .chat-input input {
            flex: 1;
            padding: 0.75rem 1rem;
            border: 2px solid #e2e8f0;
            border-radius: 25px;
            font-size: 1rem;
            outline: none;
            transition: all 0.3s ease;
            background: white;
        }
        
        .chat-input input:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .chat-input button {
            padding: 0.75rem 1.5rem;
            border: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .chat-input button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .chat-input button:active {
            transform: translateY(0);
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideIn {
            from { 
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to { 
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        .modal-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            width: 90%;
            max-width: 450px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            animation: slideIn 0.3s ease;
        }
        
        .modal h2 {
            margin-top: 0;
            margin-bottom: 1rem;
            color: #333;
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .modal p {
            color: #666;
            margin-bottom: 1.5rem;
            line-height: 1.5;
        }
        
        .modal input {
            width: 100%;
            padding: 0.75rem 1rem;
            margin: 0.5rem 0 1.5rem 0;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            box-sizing: border-box;
            font-size: 1rem;
            outline: none;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.8);
        }
        
        .modal input:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            background: white;
        }
        
        .modal button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            margin-right: 0.5rem;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .modal button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .modal button:last-child {
            background: #6c757d;
            box-shadow: 0 4px 15px rgba(108, 117, 125, 0.3);
        }
        
        .modal button:last-child:hover {
            background: #545b62;
            box-shadow: 0 6px 20px rgba(108, 117, 125, 0.4);
        }
        
        .error-message {
            background: linear-gradient(135deg, #f44336 0%, #e53935 100%);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 10px;
            margin: 1rem 0;
            font-size: 0.875rem;
            box-shadow: 0 4px 15px rgba(244, 67, 54, 0.3);
            animation: slideIn 0.3s ease;
        }
        
        .success-message {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            padding: 0.75rem 1rem;
            border-radius: 10px;
            margin: 1rem 0;
            font-size: 0.875rem;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
            animation: slideIn 0.3s ease;
        }
        
        .api-key-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            color: #333;
            padding: 0.75rem 1rem;
            border-radius: 15px;
            font-size: 0.875rem;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            user-select: none;
        }
        
        .api-key-status:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            background: rgba(255, 255, 255, 0.95);
        }
        
        .api-key-status:active {
            transform: translateY(0);
        }
        
        .api-key-status.set {
            background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
            color: white;
            border: 1px solid rgba(76, 175, 80, 0.3);
        }
        
        .api-key-status.set:hover {
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.3);
        }
        
        .api-key-status.not-set {
            background: linear-gradient(135deg, #f44336 0%, #e53935 100%);
            color: white;
            border: 1px solid rgba(244, 67, 54, 0.3);
        }
        
        .api-key-status.not-set:hover {
            box-shadow: 0 6px 20px rgba(244, 67, 54, 0.3);
        }
        
        .model-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            color: #333;
            padding: 0.75rem 1rem;
            border-radius: 15px;
            font-size: 0.875rem;
            font-weight: 500;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        
        .provider-selection {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .provider-option {
            flex: 1;
            padding: 0.75rem;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.8);
            position: relative;
        }
        
        .provider-option.active {
            border-color: #667eea;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .provider-option:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }
        
        .provider-option .key-status {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #f44336;
        }
        
        .provider-option .key-status.has-key {
            background: #4caf50;
        }
        
        .api-key-section {
            display: none;
            margin: 1rem 0;
            padding: 1rem;
            border: 1px solid #e2e8f0;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.5);
        }
        
        .api-key-section h4 {
            margin: 0 0 0.5rem 0;
            color: #333;
            font-size: 1rem;
        }
        
        .api-key-section.current {
            display: block;
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.05);
        }
        
        .key-input-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        
        .key-input-group input {
            flex: 1;
        }

        .key-input-wrapper {
            position: relative;
            flex: 1;
            display: flex;
            align-items: center;
        }

        .key-input-wrapper input {
            width: 100%;
            padding-right: 2.5rem;
        }

        .toggle-password {
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            user-select: none;
        }
        
        .validate-btn {
            padding: 0.5rem 1rem;
            border: 1px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 10px;
            cursor: pointer;
            font-size: 0.875rem;
            transition: all 0.3s ease;
            white-space: nowrap;
        }
        
        .validate-btn:hover {
            background: #667eea;
            color: white;
        }
        
        .validate-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .key-status-text {
            font-size: 0.875rem;
            margin-top: 0.5rem;
            padding: 0.5rem;
            border-radius: 8px;
        }
        
        .key-status-text.valid {
            background: rgba(76, 175, 80, 0.1);
            color: #2e7d32;
        }
        
        .key-status-text.invalid {
            background: rgba(244, 67, 54, 0.1);
            color: #c62828;
        }
        
        .key-status-text.testing {
            background: rgba(255, 193, 7, 0.1);
            color: #f57c00;
        }
        
        .model-selection {
            margin: 1rem 0;
        }
        
        .model-selection select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 2px solid #e2e8f0;
            border-radius: 15px;
            font-size: 1rem;
            outline: none;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.8);
        }
        
        .model-selection select:focus {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .message {
            margin: 0.75rem 0;
            padding: 0.75rem 1rem;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            animation: slideUp 0.3s ease;
            line-height: 1.4;
        }
        
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .user-message {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            align-self: flex-end;
            margin-left: auto;
            border-bottom-right-radius: 8px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .gpt-message {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            align-self: flex-start;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-bottom-left-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        
        .loading {
            font-style: italic;
            color: #666;
            opacity: 0.8;
        }
        
        .typing-indicator {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            align-self: flex-start;
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-bottom-left-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            margin: 0.75rem 0;
            padding: 0.75rem 1rem;
            border-radius: 18px;
            max-width: 80%;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .typing-dots {
            display: flex;
            gap: 0.25rem;
        }
        
        .typing-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #667eea;
            animation: typingAnimation 1.4s infinite;
        }
        
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        
        @keyframes typingAnimation {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.4;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }
        
        .chat-input button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
        
        .chat-input button:disabled:hover {
            transform: none !important;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3) !important;
        }
        
        @media (max-width: 768px) {
            .game-container {
                width: 95%;
                margin: 1rem 0;
            }
            
            .chosen-characters {
                flex-direction: column;
                gap: 1rem;
                margin-bottom: 1.5rem;
            }
            
            .chosen-card {
                width: 100px;
                height: 133px;
            }
            
            .chosen-card.face-down {
                font-size: 2.5rem;
            }
            
            .chat-messages {
                height: 250px;
            }
            
            .modal-content {
                width: 95%;
                padding: 1.5rem;
            }
            
            .api-key-status {
                position: static;
                margin: 1rem;
                text-align: center;
            }
            
            .message {
                max-width: 90%;
            }
            
            .llm-board {
                min-height: 350px;
            }
            
            .llm-cards-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                gap: 0.3rem 0.3rem;
            }
            
            .llm-character-card {
                width: 60px;
                height: 80px;
            }
            
            .llm-board-header h3 {
                font-size: 1.3rem;
            }
            
            .system-prompt-button {
                bottom: 15px;
                right: 15px;
                width: 50px;
                height: 50px;
                font-size: 20px;
            }
            
            .system-prompt-modal-content {
                width: 95%;
                padding: 1.5rem;
                max-height: 85vh;
            }
            
            .system-prompt-textarea {
                height: 300px;
                font-size: 0.85rem;
            }
            
            .system-prompt-actions {
                flex-direction: column;
            }
            
            .system-prompt-actions button {
                min-width: unset;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Guess Who</h1>
    </header>
    <div class="model-indicator" id="modelIndicator">
        No Model Selected
    </div>
    
    <div class="api-key-status" id="apiKeyStatus" onclick="showApiKeyModal()">
        API Key: Not Set
    </div>

    <div class="game-container">
        <div class="board">
            <div class="loading-board" id="loadingBoard">
                Loading characters...
            </div>
            <div class="cards-grid" id="cardsGrid" style="display: none;">
                <!-- Character cards will be loaded here -->
            </div>
        </div>
        <div class="chosen-characters">
            <div class="chosen-character">
                <h3>Your Character</h3>
                <div class="chosen-card" id="userChosenCard">
                    <img id="userChosenImage" src="" alt="">
                </div>
            </div>
            <div class="chosen-character">
                <h3>Opponent's Character</h3>
                <div class="chosen-card face-down" id="opponentChosenCard">
                </div>
            </div>
        </div>
        <div class="chat-container">
            <div class="chat-messages" id="chatMessages">
                <!-- Chat messages will appear here -->
            </div>
            <div class="chat-input">
                <input type="text" id="chatInput" placeholder="Type your message..." onkeypress="handleKeyPress(event)">
                <button onclick="sendMessage()">Send</button>
            </div>
        </div>
        <div class="llm-board">
            <div class="llm-board-header">
                <h3>AI's Board</h3>
            </div>
            <div class="loading-llm-board" id="loadingLLMBoard">
                Loading AI board...
            </div>
            <div class="llm-cards-grid" id="llmCardsGrid" style="display: none;">
                <!-- LLM character cards will be loaded here -->
            </div>
        </div>
    </div>

    <!-- System Prompt Button -->
    <button class="system-prompt-button" onclick="showSystemPromptModal()" title="Edit System Prompt">
        ‚öôÔ∏è
    </button>

    <!-- API Key Modal -->
    <div id="apiKeyModal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle">AI Model Configuration</h2>
            <p id="modalDescription">Choose your AI provider and configure your API keys:</p>
            <div id="modalMessage"></div>
            
            <div class="provider-selection">
                <div class="provider-option active" id="openaiProvider" onclick="selectProvider('openai')">
                    <div class="key-status" id="openaiKeyStatus"></div>
                    <strong>OpenAI</strong><br>
                    <small>GPT-5, GPT-5 Mini, GPT-5 Nano, GPT-4o</small>
                </div>
                <div class="provider-option" id="anthropicProvider" onclick="selectProvider('anthropic')">
                    <div class="key-status" id="anthropicKeyStatus"></div>
                    <strong>Anthropic</strong><br>
                    <small>Claude Opus 4, Claude Sonnet 4</small>
                </div>
                <div class="provider-option" id="googleProvider" onclick="selectProvider('google')">
                    <div class="key-status" id="googleKeyStatus"></div>
                    <strong>Google</strong><br>
                    <small>Gemini 2.5 Pro, 2.5 Flash, 2.5 Flash Lite</small>
                </div>
            </div>
            
            <div class="model-selection">
                <label for="modelSelect"><strong>Selected Model:</strong></label>
                <select id="modelSelect" onchange="updateSelectedModel()">
                    <option value="gpt-4o">GPT-4o</option>
                    <option value="gpt-4o-mini">GPT-4o Mini</option>
                    <option value="gpt-5">GPT-5</option>
                    <option value="gpt-5-mini">GPT-5 Mini</option>
                    <option value="gpt-5-nano">GPT-5 Nano</option>
                </select>
            </div>

            <div class="api-key-section current" id="openaiSection">
                <h4>OpenAI API Key</h4>
                <div class="key-input-group">
                    <div class="key-input-wrapper">
                        <input type="password" id="openaiKeyInput" placeholder="sk-..." />
                        <span class="toggle-password">üëÅÔ∏è</span>
                    </div>
                    <button class="validate-btn" onclick="validateProviderKey('openai')" id="openaiValidateBtn">Test Key</button>
                </div>
                <div class="key-status-text" id="openaiKeyStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section" id="anthropicSection">
                <h4>Anthropic API Key</h4>
                <div class="key-input-group">
                    <div class="key-input-wrapper">
                        <input type="password" id="anthropicKeyInput" placeholder="sk-ant-..." />
                        <span class="toggle-password">üëÅÔ∏è</span>
                    </div>
                    <button class="validate-btn" onclick="validateProviderKey('anthropic')" id="anthropicValidateBtn">Test Key</button>
                </div>
                <div class="key-status-text" id="anthropicKeyStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section" id="googleSection">
                <h4>Google API Key</h4>
                <div class="key-input-group">
                    <div class="key-input-wrapper">
                        <input type="password" id="googleKeyInput" placeholder="AIza..." />
                        <span class="toggle-password">üëÅÔ∏è</span>
                    </div>
                    <button class="validate-btn" onclick="validateProviderKey('google')" id="googleValidateBtn">Test Key</button>
                </div>
                <div class="key-status-text" id="googleKeyStatusText" style="display: none;"></div>
            </div>
            
            <div>
                <button onclick="saveConfiguration()" id="saveButton">Save Configuration</button>
                <button onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- System Prompt Modal -->
    <div id="systemPromptModal" class="system-prompt-modal">
        <div class="system-prompt-modal-content">
            <h2>System Prompt Editor</h2>
            <p>Customize how the AI behaves in the game. This controls the AI's personality, knowledge, and gameplay style.</p>
            <textarea id="systemPromptTextarea" class="system-prompt-textarea" placeholder="Enter your system prompt here..."></textarea>
            <div class="system-prompt-actions">
                <button class="save-prompt-btn" onclick="saveSystemPrompt()">Save Changes</button>
                <button class="reset-prompt-btn" onclick="resetSystemPrompt()">Reset to Default</button>
                <button class="cancel-prompt-btn" onclick="closeSystemPromptModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.querySelector('.chat-input button');
        const apiKeyModal = document.getElementById('apiKeyModal');
        const apiKeyStatus = document.getElementById('apiKeyStatus');
        const modelIndicator = document.getElementById('modelIndicator');
        const modalMessage = document.getElementById('modalMessage');
        const saveButton = document.getElementById('saveButton');
        const modelSelect = document.getElementById('modelSelect');
        const openaiProvider = document.getElementById('openaiProvider');
        const anthropicProvider = document.getElementById('anthropicProvider');
        const googleProvider = document.getElementById('googleProvider');
        
        // New elements for multi-key support
        const openaiKeyInput = document.getElementById('openaiKeyInput');
        const anthropicKeyInput = document.getElementById('anthropicKeyInput');
        const googleKeyInput = document.getElementById('googleKeyInput');
        const openaiKeyStatus = document.getElementById('openaiKeyStatus');
        const anthropicKeyStatus = document.getElementById('anthropicKeyStatus');
        const googleKeyStatus = document.getElementById('googleKeyStatus');
        const openaiSection = document.getElementById('openaiSection');
        const anthropicSection = document.getElementById('anthropicSection');
        const googleSection = document.getElementById('googleSection');
        const openaiKeyStatusText = document.getElementById('openaiKeyStatusText');
        const anthropicKeyStatusText = document.getElementById('anthropicKeyStatusText');
        const googleKeyStatusText = document.getElementById('googleKeyStatusText');
        const openaiValidateBtn = document.getElementById('openaiValidateBtn');
        const anthropicValidateBtn = document.getElementById('anthropicValidateBtn');
        const googleValidateBtn = document.getElementById('googleValidateBtn');
        
        // Game board elements
        const loadingBoard = document.getElementById('loadingBoard');
        const cardsGrid = document.getElementById('cardsGrid');
        const loadingLLMBoard = document.getElementById('loadingLLMBoard');
        const llmCardsGrid = document.getElementById('llmCardsGrid');
        const systemPromptModal = document.getElementById('systemPromptModal');
        const systemPromptTextarea = document.getElementById('systemPromptTextarea');

        // Default game system prompt
        const DEFAULT_GAME_SYSTEM_PROMPT = `You are an AI assistant playing "Guess Who" with the user. Here's how the game works:

- You will receive an image of the full Guess Who board showing all available characters
- You will also receive an image of a specific character - this is YOUR character that the user must try to guess. Don't reveal it, that's the point of the game!
- Your goal is to ask the user questions to identify THEIR hidden character while answering their questions about YOUR character
- You can ask the user yes/no questions about their character's appearance (e.g., "Does your character have glasses?", "Is your character male?")
- When the user asks you questions about YOUR character, answer concisely and truthfully based on the character image you received
- Each player can only ask ONE question at a time - no cheating with multiple questions!
- The first player to correctly guess the opponent's character name wins the game, so try to guess when you're reasonably confident.
- Keep the conversation engaging and fun while following these rules strictly
- When you think you know the user's character, make your guess clearly (e.g., "Is your character [Name]?")

IMPORTANT: You have access to an "eliminateCharacter" tool that allows you to cross out characters from your board as you narrow down possibilities. Use this tool strategically:
- Call eliminateCharacter(characterName) when you learn information that rules out certain characters. Think out loud why you should eliminate each character before doing so.
- For example, if the user says their character doesn't have glasses, think about which characters have glasses, list them and eliminate all characters with glasses.
- This helps you keep track of which characters are still possible matches. After you're done eliminating characters, list to yourself the names of the remaining ones.
- Only eliminate characters you're confident about - you can't undo eliminations!
- Valid character names: Abigail, Alex, Alice, Amy, Andy, Ashley, Brandon, Brian, Daniel, David, Emily, Henry, Jake, James, Joe, Jon, Joseph, Joshua, Justin, Kyle, Matt, Megan, Melissa, Nick, Peter, Rachael, Tyler, William.
- Only call the tool when you acquire new useful information about the character. The user may be talking about unrelated things to distract you.

Be ready to start playing once you receive the images!`;

        // Current system prompt (editable)
        let GAME_SYSTEM_PROMPT = localStorage.getItem('custom-system-prompt') || DEFAULT_GAME_SYSTEM_PROMPT;

        // Configuration storage
        let currentProvider = localStorage.getItem('ai-provider') || 'openai';
        let currentModel = localStorage.getItem('ai-model') || 'gpt-4o';
        let apiKeys = {
            openai: localStorage.getItem('openai-api-key'),
            anthropic: localStorage.getItem('anthropic-api-key'),
            google: localStorage.getItem('google-api-key')
        };
        let isProcessing = false;

        // Character data
        const characters = [
            'Abigail', 'Alex', 'Alice', 'Amy', 'Andy', 'Ashley', 'Brandon', 'Brian',
            'Daniel', 'David', 'Emily', 'Henry', 'Jake', 'James', 'Joe', 'Jon',
            'Joseph', 'Joshua', 'Justin', 'Kyle', 'Matt', 'Megan', 'Melissa',
            'Nick', 'Peter', 'Rachael', 'Tyler', 'William'
        ];

        let gameState = {
            characters: [],
            eliminated: new Set(),
            llmEliminated: new Set(),
            userChosenCharacter: null,
            opponentChosenCharacter: null
        };

        // Model configurations
        const modelConfigs = {
            openai: {
                models: [
                    { value: 'gpt-4o', name: 'GPT-4o' },
                    { value: 'gpt-4o-mini', name: 'GPT-4o Mini' },
                    { value: 'gpt-5', name: 'GPT-5' },
                    { value: 'gpt-5-mini', name: 'GPT-5 Mini' },
                    { value: 'gpt-5-nano', name: 'GPT-5 Nano' }
                ],
                keyPrefix: 'sk-',
                keyPlaceholder: 'sk-...'
            },
            anthropic: {
                models: [
                    { value: 'claude-opus-4-1', name: 'Claude 4.1 Opus' },
                    { value: 'claude-opus-4-0', name: 'Claude 4.0 Opus' },
                    { value: 'claude-sonnet-4-0', name: 'Claude 4.0 Sonnet' },
                    { value: 'claude-3-7-sonnet-latest', name: 'Claude 3.7 Sonnet' },
                ],
                keyPrefix: 'sk-ant-',
                keyPlaceholder: 'sk-ant-...'
            },
            google: {
                models: [
                    { value: 'gemini-2.5-pro', name: 'Gemini 2.5 Pro' },
                    { value: 'gemini-2.5-flash', name: 'Gemini 2.5 Flash' },
                    { value: 'gemini-2.5-flash-lite', name: 'Gemini 2.5 Flash Lite' }
                ],
                keyPrefix: 'AIza',
                keyPlaceholder: 'AIza...'
            }
        };

        function updateApiKeyStatus() {
            const hasApiKey = apiKeys[currentProvider];
            if (hasApiKey) {
                apiKeyStatus.textContent = 'API Key: Set';
                apiKeyStatus.className = 'api-key-status set';
            } else {
                apiKeyStatus.textContent = 'API Key: Not Set';
                apiKeyStatus.className = 'api-key-status not-set';
            }
        }

        function updateKeyStatusIndicators() {
            // Update OpenAI key status indicator
            if (apiKeys.openai) {
                openaiKeyStatus.classList.add('has-key');
            } else {
                openaiKeyStatus.classList.remove('has-key');
            }

            // Update Anthropic key status indicator
            if (apiKeys.anthropic) {
                anthropicKeyStatus.classList.add('has-key');
            } else {
                anthropicKeyStatus.classList.remove('has-key');
            }

            // Update Google key status indicator
            if (apiKeys.google) {
                googleKeyStatus.classList.add('has-key');
            } else {
                googleKeyStatus.classList.remove('has-key');
            }
        }

        function updateModelIndicator() {
            const config = modelConfigs[currentProvider];
            const modelName = config.models.find(m => m.value === currentModel)?.name || currentModel;
            const providerName = currentProvider.charAt(0).toUpperCase() + currentProvider.slice(1);
            modelIndicator.textContent = `${providerName}: ${modelName}`;
        }

        function selectProvider(provider) {
            currentProvider = provider;
            
            // Update provider selection UI
            openaiProvider.classList.remove('active');
            anthropicProvider.classList.remove('active');
            googleProvider.classList.remove('active');
            document.getElementById(provider + 'Provider').classList.add('active');
            
            // Update section highlighting
            openaiSection.classList.remove('current');
            anthropicSection.classList.remove('current');
            googleSection.classList.remove('current');
            document.getElementById(provider + 'Section').classList.add('current');
            
            // Update model dropdown
            updateModelDropdown();
            updateApiKeyStatus();
            updateModelIndicator();
        }

        function updateModelDropdown() {
            const config = modelConfigs[currentProvider];
            modelSelect.innerHTML = '';
            
            config.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.name;
                modelSelect.appendChild(option);
            });
            
            // Set model based on current selection or default
            const savedModel = localStorage.getItem('ai-model');
            if (savedModel && config.models.some(m => m.value === savedModel)) {
                currentModel = savedModel;
            } else {
                // Set default model for provider
                if (currentProvider === 'openai') {
                    currentModel = 'gpt-4o';
                } else if (currentProvider === 'anthropic') {
                    currentModel = 'claude-3-7-sonnet-latest';
                } else {
                    currentModel = 'gemini-2.5-pro';
                }
            }
            modelSelect.value = currentModel;
        }

        function updateSelectedModel() {
            currentModel = modelSelect.value;
        }

        function showApiKeyModal() {
            const modalTitle = document.getElementById('modalTitle');
            const modalDescription = document.getElementById('modalDescription');
            
            modalTitle.textContent = 'AI Model Configuration';
            modalDescription.textContent = 'Choose your AI provider and configure your API keys:';
            
            // Set up the modal with current configuration
            selectProvider(currentProvider);
            modelSelect.value = currentModel;
            
            // Populate existing API keys
            if (apiKeys.openai) {
                openaiKeyInput.value = apiKeys.openai;
            }
            if (apiKeys.anthropic) {
                anthropicKeyInput.value = apiKeys.anthropic;
            }
            if (apiKeys.google) {
                googleKeyInput.value = apiKeys.google;
            }
            
            // Update key status indicators
            updateKeyStatusIndicators();
            
            // Clear any previous messages
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
            
            apiKeyModal.style.display = 'block';
        }

        function showModalMessage(message, isError = false) {
            modalMessage.innerHTML = `<div class="${isError ? 'error-message' : 'success-message'}">${message}</div>`;
        }

        function closeModal() {
            apiKeyModal.style.display = 'none';
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
        }

        function clearAllKeyStatusTexts() {
            openaiKeyStatusText.style.display = 'none';
            anthropicKeyStatusText.style.display = 'none';
            googleKeyStatusText.style.display = 'none';
        }

        function showKeyStatus(provider, message, status) {
            let statusElement;
            if (provider === 'openai') {
                statusElement = openaiKeyStatusText;
            } else if (provider === 'anthropic') {
                statusElement = anthropicKeyStatusText;
            } else {
                statusElement = googleKeyStatusText;
            }
            statusElement.textContent = message;
            statusElement.className = `key-status-text ${status}`;
            statusElement.style.display = 'block';
        }

        async function validateProviderKey(provider) {
            let keyInput, validateBtn;
            if (provider === 'openai') {
                keyInput = openaiKeyInput;
                validateBtn = openaiValidateBtn;
            } else if (provider === 'anthropic') {
                keyInput = anthropicKeyInput;
                validateBtn = anthropicValidateBtn;
            } else {
                keyInput = googleKeyInput;
                validateBtn = googleValidateBtn;
            }
            const key = keyInput.value.trim();
            const config = modelConfigs[provider];

            if (!key) {
                showKeyStatus(provider, 'Please enter an API key', 'invalid');
                return false;
            }

            if (provider !== 'google' && !key.startsWith(config.keyPrefix)) {
                showKeyStatus(provider, `API key should start with "${config.keyPrefix}"`, 'invalid');
                return false;
            }

            validateBtn.disabled = true;
            validateBtn.textContent = 'Testing...';
            showKeyStatus(provider, 'Testing API key...', 'testing');

            try {
                // Get a default model for testing
                const testModel = config.models[0].value;
                
                if (provider === 'openai') {
                    await validateOpenAIKey(key, testModel);
                } else if (provider === 'anthropic') {
                    await validateAnthropicKey(key, testModel);
                } else if (provider === 'google') {
                    await validateGoogleKey(key, testModel);
                }

                showKeyStatus(provider, '‚úì API key is valid!', 'valid');
                return true;

            } catch (error) {
                showKeyStatus(provider, error.message, 'invalid');
                return false;
            } finally {
                validateBtn.disabled = false;
                validateBtn.textContent = 'Test Key';
            }
        }

        async function saveConfiguration() {
            const openaiKey = openaiKeyInput.value.trim();
            const anthropicKey = anthropicKeyInput.value.trim();
            const googleKey = googleKeyInput.value.trim();
            
            // Validate that the selected provider has a key
            let selectedProviderKey;
            if (currentProvider === 'openai') {
                selectedProviderKey = openaiKey;
            } else if (currentProvider === 'anthropic') {
                selectedProviderKey = anthropicKey;
            } else {
                selectedProviderKey = googleKey;
            }

            if (!selectedProviderKey) {
                showModalMessage(`Please enter an API key for ${currentProvider.charAt(0).toUpperCase() + currentProvider.slice(1)} to use this provider.`, true);
                return;
            }

            saveButton.disabled = true;
            saveButton.textContent = 'Saving...';

            try {
                // Save OpenAI key if provided
                if (openaiKey) {
                    apiKeys.openai = openaiKey;
                    localStorage.setItem('openai-api-key', openaiKey);
                } else if (apiKeys.openai) {
                    // Keep existing key if no new one provided
                    openaiKeyInput.value = apiKeys.openai;
                }

                // Save Anthropic key if provided
                if (anthropicKey) {
                    apiKeys.anthropic = anthropicKey;
                    localStorage.setItem('anthropic-api-key', anthropicKey);
                } else if (apiKeys.anthropic) {
                    // Keep existing key if no new one provided
                    anthropicKeyInput.value = apiKeys.anthropic;
                }

                // Save Google key if provided
                if (googleKey) {
                    apiKeys.google = googleKey;
                    localStorage.setItem('google-api-key', googleKey);
                } else if (apiKeys.google) {
                    // Keep existing key if no new one provided
                    googleKeyInput.value = apiKeys.google;
                }

                // Save current provider and model
                localStorage.setItem('ai-provider', currentProvider);
                localStorage.setItem('ai-model', currentModel);

                // Update UI
                updateApiKeyStatus();
                updateModelIndicator();
                updateKeyStatusIndicators();

                showModalMessage('Configuration saved successfully!', false);

                // Close modal after delay
                setTimeout(() => {
                    closeModal();
                }, 500);

            } catch (error) {
                showModalMessage(error.message, true);
            } finally {
                saveButton.disabled = false;
                saveButton.textContent = 'Save Configuration';
            }
        }

                async function validateOpenAIKey(key, model) {
            const params = {
                model: model,
                messages: [{ role: 'user', content: 'test' }],
                stream: false
            };

            if (model.includes('gpt-5')) {
                params.max_completion_tokens = 1;
            } else {
                params.max_tokens = 1;
            }

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${key}`
                },
                body: JSON.stringify(params)
            });

            if (response.status === 401) {
                throw new Error('Invalid API key. Please check your OpenAI API key and try again.');
            } else if (response.status === 429) {
                throw new Error('Rate limit exceeded. Your API key is valid but you\'ve hit the rate limit.');
            } else if (response.status === 403) {
                throw new Error('API key does not have access to the required model.');
            } else if (!response.ok) {
                throw new Error(`API validation failed (${response.status}). Please try again.`);
            }
        }

        async function validateAnthropicKey(key, model) {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': key,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'user', content: 'Hi' }],
                    max_tokens: 1,
                    stream: false
                })
            });

            if (response.status === 401) {
                throw new Error('Invalid API key. Please check your Anthropic API key and try again.');
            } else if (response.status === 429) {
                throw new Error('Rate limit exceeded. Your API key is valid but you\'ve hit the rate limit.');
            } else if (response.status === 403) {
                throw new Error('API key does not have access to the required model.');
            } else if (response.status === 400) {
                // Check if it's a bad request due to invalid model or key format
                const errorData = await response.json().catch(() => null);
                if (errorData && errorData.error && errorData.error.message) {
                    if (errorData.error.message.includes('model') || errorData.error.message.includes('Model')) {
                        throw new Error('Selected model is not available with this API key.');
                    } else {
                        throw new Error(`API key validation failed: ${errorData.error.message}`);
                    }
                } else {
                    throw new Error('Invalid API key format or request. Please check your Anthropic API key.');
                }
            } else if (!response.ok) {
                const errorData = await response.json().catch(() => null);
                const errorMessage = errorData?.error?.message || `API validation failed (${response.status}). Please try again.`;
                throw new Error(errorMessage);
            }
        }

        async function validateGoogleKey(key, model) {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (response.status === 400) {
                throw new Error('Invalid API key. Please check your Google API key and try again.');
            } else if (response.status === 429) {
                throw new Error('Rate limit exceeded. Your API key is valid but you\'ve hit the rate limit.');
            } else if (response.status === 403) {
                throw new Error('API key does not have access to the required model.');
            } else if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error.message || `API validation failed (${response.status}). Please try again.`);
            }
        }


        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        function addMessage(content, isUser = false) {
            const messageElement = document.createElement('div');
            messageElement.className = `message ${isUser ? 'user-message' : 'gpt-message'}`;
            messageElement.textContent = content;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function showTypingIndicator() {
            const typingElement = document.createElement('div');
            typingElement.className = 'typing-indicator';
            typingElement.innerHTML = `
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            `;
            chatMessages.appendChild(typingElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            return typingElement;
        }

        function setProcessingState(processing) {
            isProcessing = processing;
            sendButton.disabled = processing;
            chatInput.disabled = processing;
            if (processing) {
                sendButton.textContent = 'Sending...';
            } else {`You are a helpful AI assistant playing a game of "Guess Who" with the user. Be engaging and fun while helping them play the game.`
                sendButton.textContent = 'Send';
            }
        }

        async function getImageAsBase64(imagePath) {
            try {
                const response = await fetch(imagePath);
                const blob = await response.blob();
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64 = reader.result.split(',')[1]; // Remove data:image/png;base64, prefix
                        resolve(base64);
                    };
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('Error loading image:', error);
                return '';
            }
        }

        // Track if this is the first message of the game
        let isFirstGameMessage = true;
        
        // Conversation history
        let conversationHistory = [];

        // Function definitions for AI tools
        const ELIMINATE_CHARACTER_FUNCTION = {
            name: 'eliminateCharacter',
            description: 'Eliminate a character from your board when you learn they cannot be the user\'s character',
            parameters: {
                type: 'object',
                properties: {
                    characterName: {
                        type: 'string',
                        description: 'The exact name of the character to eliminate from the board',
                        enum: characters
                    }
                },
                required: ['characterName']
            }
        };

        async function callOpenAI(message, isFirstMessage = false) {
            const messages = [];
            
            // Always add system message
            messages.push({
                role: 'system',
                content: GAME_SYSTEM_PROMPT
            });
            
            if (isFirstMessage) {
                // Add user message with board image and opponent character image
                const firstUserMessage = {
                    role: 'user',
                    content: [
                        {
                            type: 'text',
                            text: `Let's play Guess Who! Here's the game board and your character. ${message}`
                        },
                        {
                            type: 'image_url',
                            image_url: {
                                url: `data:image/png;base64,${await getImageAsBase64('./full-board.png')}`
                            }
                        },
                        {
                            type: 'image_url',
                            image_url: {
                                url: `data:image/png;base64,${await getImageAsBase64(`./guess-who-people/${gameState.opponentChosenCharacter}.png`)}`
                            }
                        }
                    ]
                };
                messages.push(firstUserMessage);
                // Store in conversation history
                conversationHistory.push(firstUserMessage);
            } else {
                // Add all conversation history
                messages.push(...conversationHistory);
                
                // Add current user message
                const currentUserMessage = {
                    role: 'user',
                    content: message
                };
                messages.push(currentUserMessage);
                // Store in conversation history
                conversationHistory.push(currentUserMessage);
            }

            const params = {
                model: currentModel,
                messages: messages,
                tools: [
                    {
                        type: 'function',
                        function: ELIMINATE_CHARACTER_FUNCTION
                    }
                ],
                tool_choice: 'auto',
                stream: true
            };

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKeys.openai}`
                },
                body: JSON.stringify(params)
            });

            if (!response.ok) {
                if (response.status === 401) {
                    throw new Error('Invalid API key. Please check your OpenAI API key.');
                } else if (response.status === 429) {
                    throw new Error('Rate limit exceeded. Please try again later.');
                } else {
                    throw new Error(`API request failed: ${response.status}`);
                }
            }

            return response;
        }

        async function callAnthropic(message, isFirstMessage = false) {
            const messages = [];
            
            if (isFirstMessage) {
                // Add user message with images for Anthropic
                const firstUserMessage = {
                    role: 'user',
                    content: [
                        {
                            type: 'text',
                            text: `Let's play Guess Who! Here's the game board and your character. ${message}`
                        },
                        {
                            type: 'image',
                            source: {
                                type: 'base64',
                                media_type: 'image/png',
                                data: await getImageAsBase64('./full-board.png')
                            }
                        },
                        {
                            type: 'image',
                            source: {
                                type: 'base64',
                                media_type: 'image/png',
                                data: await getImageAsBase64(`./guess-who-people/${gameState.opponentChosenCharacter}.png`)
                            }
                        }
                    ]
                };
                messages.push(firstUserMessage);
                // Store in conversation history (without images for subsequent messages)
                conversationHistory.push({
                    role: 'user',
                    content: `Let's play Guess Who! Here's the game board and your character. ${message}`
                });
            } else {
                // Add all conversation history
                messages.push(...conversationHistory);
                
                // Add current user message
                const currentUserMessage = {
                    role: 'user',
                    content: message
                };
                messages.push(currentUserMessage);
                // Store in conversation history
                conversationHistory.push(currentUserMessage);
            }

            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKeys.anthropic,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: currentModel,
                    system: GAME_SYSTEM_PROMPT,
                    messages: messages,
                    tools: [
                        {
                            name: 'eliminateCharacter',
                            description: 'Eliminate a character from your board when you learn they cannot be the user\'s character',
                            input_schema: {
                                type: 'object',
                                properties: {
                                    characterName: {
                                        type: 'string',
                                        description: 'The exact name of the character to eliminate from the board',
                                        enum: characters
                                    }
                                },
                                required: ['characterName']
                            }
                        }
                    ],
                    stream: true,
                    max_tokens: 1000
                })
            });

            if (!response.ok) {
                if (response.status === 401) {
                    throw new Error('Invalid API key. Please check your Anthropic API key.');
                } else if (response.status === 429) {
                    throw new Error('Rate limit exceeded. Please try again later.');
                } else {
                    throw new Error(`API request failed: ${response.status}`);
                }
            }

            return response;
        }

        async function callGemini(message, isFirstMessage = false) {
            const contents = [];
            
            if (isFirstMessage) {
                // Add user message with images for Gemini
                const firstUserMessage = {
                    role: 'user',
                    parts: [
                        { text: `${GAME_SYSTEM_PROMPT}\n\nLet's play Guess Who! Here's the game board and your character. ${message}` },
                        {
                            inlineData: {
                                mimeType: 'image/png',
                                data: await getImageAsBase64('./full-board.png')
                            }
                        },
                        {
                            inlineData: {
                                mimeType: 'image/png',
                                data: await getImageAsBase64(`./guess-who-people/${gameState.opponentChosenCharacter}.png`)
                            }
                        }
                    ]
                };
                contents.push(firstUserMessage);
                // Store in conversation history (text only for subsequent messages)
                conversationHistory.push({
                    role: 'user',
                    parts: [{ text: `Let's play Guess Who! Here's the game board and your character. ${message}` }]
                });
            } else {
                // Add all conversation history
                contents.push(...conversationHistory);
                
                // Add current user message
                const currentUserMessage = {
                    role: 'user',
                    parts: [{ text: message }]
                };
                contents.push(currentUserMessage);
                // Store in conversation history
                conversationHistory.push(currentUserMessage);
            }

            const response = await fetch(`https://generativelanguage.googleapis.com/v1/models/${currentModel}:streamGenerateContent?key=${apiKeys.google}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: contents,
                    tools: [
                        {
                            functionDeclarations: [
                                {
                                    name: 'eliminateCharacter',
                                    description: 'Eliminate a character from your board when you learn they cannot be the user\'s character',
                                    parameters: {
                                        type: 'object',
                                        properties: {
                                            characterName: {
                                                type: 'string',
                                                description: 'The exact name of the character to eliminate from the board',
                                                enum: characters
                                            }
                                        },
                                        required: ['characterName']
                                    }
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                    }
                })
            });

            if (!response.ok) {
                if (response.status === 400) {
                    throw new Error('Invalid API key. Please check your Google API key.');
                } else if (response.status === 429) {
                    throw new Error('Rate limit exceeded. Please try again later.');
                } else {
                    const error = await response.json();
                    throw new Error(error.error.message || `API request failed: ${response.status}`);
                }
            }

            return response;
        }

        async function streamOpenAIResponse(response, messageElement) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let fullResponse = '';
            let toolCalls = [];
            let currentToolCall = null;

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') continue;
                        
                        try {
                            const parsed = JSON.parse(data);
                            const delta = parsed.choices[0].delta;
                            
                            // Handle regular content
                            if (delta && delta.content) {
                                fullResponse += delta.content;
                                messageElement.textContent = fullResponse;
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            }
                            
                            // Handle tool calls
                            if (delta && delta.tool_calls) {
                                for (const toolCallDelta of delta.tool_calls) {
                                    const index = toolCallDelta.index;
                                    
                                    // Initialize tool call if needed
                                    if (!toolCalls[index]) {
                                        toolCalls[index] = {
                                            id: '',
                                            type: 'function',
                                            function: { name: '', arguments: '' }
                                        };
                                    }
                                    
                                    // Update tool call
                                    if (toolCallDelta.id) {
                                        toolCalls[index].id += toolCallDelta.id;
                                    }
                                    if (toolCallDelta.function) {
                                        if (toolCallDelta.function.name) {
                                            toolCalls[index].function.name += toolCallDelta.function.name;
                                        }
                                        if (toolCallDelta.function.arguments) {
                                            toolCalls[index].function.arguments += toolCallDelta.function.arguments;
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            // Ignore parsing errors for incomplete chunks
                        }
                    }
                }
            }

            // Execute any tool calls
            for (const toolCall of toolCalls) {
                if (toolCall.function.name === 'eliminateCharacter') {
                    try {
                        const args = JSON.parse(toolCall.function.arguments);
                        const result = eliminateCharacter(args.characterName);
                        
                        // Add visual feedback to chat
                        // if (result.success) {
                        //     fullResponse += `\n\n*[Eliminated ${args.characterName} from board]*`;
                        // } else {
                        //     fullResponse += `\n\n*[Failed to eliminate ${args.characterName}: ${result.message}]*`;
                        // }
                        messageElement.textContent = fullResponse;
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } catch (e) {
                        console.error('Error executing tool call:', e);
                    }
                }
            }

            return { 
                response: fullResponse, 
                hasToolCalls: toolCalls.length > 0 
            };
        }

        async function streamAnthropicResponse(response, messageElement) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let fullResponse = '';
            let toolCalls = [];
            let currentToolCall = null;

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') continue;
                        
                        try {
                            const parsed = JSON.parse(data);
                            
                            // Handle regular text content
                            if (parsed.type === 'content_block_delta' && parsed.delta && parsed.delta.text) {
                                fullResponse += parsed.delta.text;
                                messageElement.textContent = fullResponse;
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            }
                            
                            // Handle tool use start
                            if (parsed.type === 'content_block_start' && parsed.content_block && parsed.content_block.type === 'tool_use') {
                                currentToolCall = {
                                    id: parsed.content_block.id,
                                    name: parsed.content_block.name,
                                    input: ''
                                };
                            }
                            
                            // Handle tool use input delta
                            if (parsed.type === 'content_block_delta' && parsed.delta && parsed.delta.partial_json && currentToolCall) {
                                currentToolCall.input += parsed.delta.partial_json;
                            }
                            
                            // Handle tool use end
                            if (parsed.type === 'content_block_stop' && currentToolCall) {
                                toolCalls.push(currentToolCall);
                                currentToolCall = null;
                            }
                        } catch (e) {
                            // Ignore parsing errors for incomplete chunks
                        }
                    }
                }
            }

            // Execute any tool calls
            for (const toolCall of toolCalls) {
                if (toolCall.name === 'eliminateCharacter') {
                    try {
                        const args = JSON.parse(toolCall.input);
                        const result = eliminateCharacter(args.characterName);
                        
                        // Add visual feedback to chat
                        // if (result.success) {
                        //     fullResponse += `\n\n*[Eliminated ${args.characterName} from board]*`;
                        // } else {
                        //     fullResponse += `\n\n*[Failed to eliminate ${args.characterName}: ${result.message}]*`;
                        // }
                        messageElement.textContent = fullResponse;
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } catch (e) {
                        console.error('Error executing tool call:', e);
                    }
                }
            }

            return { 
                response: fullResponse, 
                hasToolCalls: toolCalls.length > 0 
            };
        }

        async function streamGeminiResponse(response, messageElement) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let fullResponse = '';
            let buffer = '';
            let toolCalls = [];

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;

                // Split by newlines but keep incomplete JSON objects in buffer
                const parts = buffer.split('\n');
                buffer = parts.pop() || ''; // Keep the last incomplete part

                for (const part of parts) {
                    const trimmed = part.trim();
                    if (trimmed && trimmed !== ',' && trimmed !== '[' && trimmed !== ']') {
                        // Remove trailing comma if present
                        const cleanJson = trimmed.endsWith(',') ? trimmed.slice(0, -1) : trimmed;
                        
                        try {
                            const parsed = JSON.parse(cleanJson);
                            if (parsed.candidates && parsed.candidates[0] && parsed.candidates[0].content) {
                                const content = parsed.candidates[0].content;
                                
                                if (content.parts) {
                                    for (const part of content.parts) {
                                        // Handle text content
                                        if (part.text) {
                                            fullResponse += part.text;
                                            messageElement.textContent = fullResponse;
                                            chatMessages.scrollTop = chatMessages.scrollHeight;
                                        }
                                        
                                        // Handle function calls
                                        if (part.functionCall) {
                                            toolCalls.push(part.functionCall);
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            // Ignore parsing errors for incomplete chunks or structural elements
                        }
                    }
                }
            }

            // Process any remaining buffer content
            if (buffer.trim()) {
                const cleanJson = buffer.trim().endsWith(',') ? buffer.trim().slice(0, -1) : buffer.trim();
                if (cleanJson && cleanJson !== ',' && cleanJson !== '[' && cleanJson !== ']') {
                    try {
                        const parsed = JSON.parse(cleanJson);
                        if (parsed.candidates && parsed.candidates[0] && parsed.candidates[0].content) {
                            const content = parsed.candidates[0].content;
                            
                            if (content.parts) {
                                for (const part of content.parts) {
                                    // Handle text content
                                    if (part.text) {
                                        fullResponse += part.text;
                                        messageElement.textContent = fullResponse;
                                        chatMessages.scrollTop = chatMessages.scrollHeight;
                                    }
                                    
                                    // Handle function calls
                                    if (part.functionCall) {
                                        toolCalls.push(part.functionCall);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        // Ignore final parsing errors
                    }
                }
            }

            // Execute any tool calls
            for (const toolCall of toolCalls) {
                if (toolCall.name === 'eliminateCharacter') {
                    try {
                        const args = toolCall.args;
                        const result = eliminateCharacter(args.characterName);
                        
                        // Add visual feedback to chat
                        // if (result.success) {
                        //     fullResponse += `\n\n*[Eliminated ${args.characterName} from board]*`;
                        // } else {
                        //     fullResponse += `\n\n*[Failed to eliminate ${args.characterName}: ${result.message}]*`;
                        // }
                        messageElement.textContent = fullResponse;
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } catch (e) {
                        console.error('Error executing tool call:', e);
                    }
                }
            }

            return { 
                response: fullResponse, 
                hasToolCalls: toolCalls.length > 0 
            };
        }

        async function callAI(message) {
            console.log('callAI called with:', { message, currentProvider, hasApiKey: !!apiKeys[currentProvider] });
            
            if (!apiKeys[currentProvider]) {
                console.log('No API key found, showing modal');
                showApiKeyModal();
                return;
            }

            setProcessingState(true);
            const typingIndicator = showTypingIndicator();

            try {
                let response;
                
                console.log('Calling API for provider:', currentProvider);
                // Call the appropriate API
                if (currentProvider === 'openai') {
                    response = await callOpenAI(message, isFirstGameMessage);
                } else if (currentProvider === 'anthropic') {
                    response = await callAnthropic(message, isFirstGameMessage);
                } else if (currentProvider === 'google') {
                    response = await callGemini(message, isFirstGameMessage);
                } else {
                    throw new Error('Unsupported provider: ' + currentProvider);
                }
                
                // After first message, set flag to false
                isFirstGameMessage = false;

                console.log('API response received, status:', response.status);

                // Remove typing indicator and create message element
                if (typingIndicator && typingIndicator.parentNode) {
                    typingIndicator.remove();
                }
                
                const aiMessageElement = document.createElement('div');
                aiMessageElement.className = 'message gpt-message';
                aiMessageElement.textContent = '';
                chatMessages.appendChild(aiMessageElement);

                // Stream the response
                let aiResponse = '';
                let hasToolCalls = false;
                if (currentProvider === 'openai') {
                    const result = await streamOpenAIResponse(response, aiMessageElement);
                    aiResponse = result.response;
                    hasToolCalls = result.hasToolCalls;
                } else if (currentProvider === 'anthropic') {
                    const result = await streamAnthropicResponse(response, aiMessageElement);
                    aiResponse = result.response;
                    hasToolCalls = result.hasToolCalls;
                } else if (currentProvider === 'google') {
                    const result = await streamGeminiResponse(response, aiMessageElement);
                    aiResponse = result.response;
                    hasToolCalls = result.hasToolCalls;
                }
                
                // Store AI response in conversation history
                if (currentProvider === 'openai' || currentProvider === 'anthropic') {
                    conversationHistory.push({
                        role: 'assistant',
                        content: aiResponse
                    });
                } else if (currentProvider === 'google') {
                    conversationHistory.push({
                        role: 'model',
                        parts: [{ text: aiResponse }]
                    });
                }

                // If the response was only tool calls with no text, prompt again for a conversational response
                if (hasToolCalls && (!aiResponse || aiResponse.trim() === '')) {
                    console.log('AI response was only tool calls, prompting for conversational response...');
                    
                    // Add a follow-up message to get conversational response
                    const followUpMessage = "Please provide your response or next question.";
                    
                    // Add the follow-up message to conversation history
                    if (currentProvider === 'openai' || currentProvider === 'anthropic') {
                        conversationHistory.push({
                            role: 'user',
                            content: followUpMessage
                        });
                    } else if (currentProvider === 'google') {
                        conversationHistory.push({
                            role: 'user',
                            parts: [{ text: followUpMessage }]
                        });
                    }
                    
                    let followUpResponse;
                    if (currentProvider === 'openai') {
                        followUpResponse = await callOpenAI(followUpMessage, false);
                    } else if (currentProvider === 'anthropic') {
                        followUpResponse = await callAnthropic(followUpMessage, false);
                    } else if (currentProvider === 'google') {
                        followUpResponse = await callGemini(followUpMessage, false);
                    }

                    // Stream the follow-up response
                    let followUpText = '';
                    if (currentProvider === 'openai') {
                        const result = await streamOpenAIResponse(followUpResponse, aiMessageElement);
                        followUpText = result.response;
                    } else if (currentProvider === 'anthropic') {
                        const result = await streamAnthropicResponse(followUpResponse, aiMessageElement);
                        followUpText = result.response;
                    } else if (currentProvider === 'google') {
                        const result = await streamGeminiResponse(followUpResponse, aiMessageElement);
                        followUpText = result.response;
                    }

                    // Combine the responses
                    aiResponse = aiResponse + (aiResponse ? '\n\n' : '') + followUpText;

                    // Update conversation history with the complete response
                    if (currentProvider === 'openai' || currentProvider === 'anthropic') {
                        conversationHistory[conversationHistory.length - 2].content = aiResponse;
                    } else if (currentProvider === 'google') {
                        conversationHistory[conversationHistory.length - 2].parts[0].text = aiResponse;
                    }

                    // Add the follow-up AI response to history
                    if (currentProvider === 'openai' || currentProvider === 'anthropic') {
                        conversationHistory.push({
                            role: 'assistant',
                            content: followUpText
                        });
                    } else if (currentProvider === 'google') {
                        conversationHistory.push({
                            role: 'model',
                            parts: [{ text: followUpText }]
                        });
                    }
                }

            } catch (error) {
                console.error('Error calling AI API:', error);
                
                // Remove typing indicator if still present
                if (typingIndicator && typingIndicator.parentNode) {
                    typingIndicator.remove();
                }
                
                // Create error message element
                const errorElement = document.createElement('div');
                errorElement.className = 'message gpt-message';
                errorElement.textContent = `Error: ${error.message}`;
                chatMessages.appendChild(errorElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                if (error.message.includes('Invalid API key')) {
                    apiKeys[currentProvider] = null;
                    localStorage.removeItem(`${currentProvider}-api-key`);
                    updateApiKeyStatus();
                    showApiKeyModal();
                }
            } finally {
                setProcessingState(false);
            }
        }

        function sendMessage() {
            const message = chatInput.value.trim();
            if (message && !isProcessing) {
                console.log('Sending message:', message);
                console.log('Current provider:', currentProvider);
                console.log('Has API key:', !!apiKeys[currentProvider]);
                addMessage(message, true);
                chatInput.value = '';
                callAI(message);
            } else {
                console.log('Message not sent - empty or processing:', { message: !!message, isProcessing });
            }
        }

        window.onclick = function(event) {
            if (event.target === apiKeyModal) {
                closeModal();
            }
            if (event.target === systemPromptModal) {
                closeSystemPromptModal();
            }
        }

        // System Prompt Modal Functions
        function showSystemPromptModal() {
            systemPromptTextarea.value = GAME_SYSTEM_PROMPT;
            systemPromptModal.style.display = 'block';
        }

        function closeSystemPromptModal() {
            systemPromptModal.style.display = 'none';
        }

        function saveSystemPrompt() {
            const newPrompt = systemPromptTextarea.value.trim();
            if (newPrompt) {
                GAME_SYSTEM_PROMPT = newPrompt;
                localStorage.setItem('custom-system-prompt', newPrompt);
                
                // Show success feedback
                const saveButton = document.querySelector('.save-prompt-btn');
                const originalText = saveButton.textContent;
                saveButton.textContent = 'Saved ‚úì';
                saveButton.style.background = 'linear-gradient(135deg, #4caf50 0%, #45a049 100%)';
                
                setTimeout(() => {
                    saveButton.textContent = originalText;
                    closeSystemPromptModal();
                }, 1000);
                
                console.log('System prompt updated successfully');
            }
        }

        function resetSystemPrompt() {
            if (confirm('Are you sure you want to reset to the default system prompt? This will overwrite your current customizations.')) {
                GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                systemPromptTextarea.value = DEFAULT_GAME_SYSTEM_PROMPT;
                localStorage.removeItem('custom-system-prompt');
                
                // Show success feedback
                const resetButton = document.querySelector('.reset-prompt-btn');
                const originalText = resetButton.textContent;
                resetButton.textContent = 'Reset ‚úì';
                
                setTimeout(() => {
                    resetButton.textContent = originalText;
                }, 1000);
                
                console.log('System prompt reset to default');
            }
        }

        // Game functions
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function createCharacterCard(name) {
            const card = document.createElement('div');
            card.className = 'character-card';
            card.dataset.character = name;
            card.onclick = () => toggleCardElimination(name);

            const img = document.createElement('img');
            img.src = `guess-who-people/${name}.png`;
            img.alt = name;
            img.onerror = () => {
                img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOTAiIGhlaWdodD0iMTIwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiNkZGQiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+Tm8gSW1hZ2U8L3RleHQ+PC9zdmc+';
            };

            card.appendChild(img);

            return card;
        }

        function createLLMCharacterCard(name) {
            const card = document.createElement('div');
            card.className = 'llm-character-card';
            card.dataset.character = name;

            const img = document.createElement('img');
            img.src = `guess-who-people/${name}.png`;
            img.alt = name;
            img.onerror = () => {
                img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzAiIGhlaWdodD0iOTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0iI2RkZCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTAiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
            };

            card.appendChild(img);

            return card;
        }

        function toggleCardElimination(name) {
            const card = cardsGrid.querySelector(`[data-character="${name}"]`);
            if (gameState.eliminated.has(name)) {
                gameState.eliminated.delete(name);
                card.classList.remove('eliminated');
            } else {
                gameState.eliminated.add(name);
                card.classList.add('eliminated');
            }
        }

        function toggleLLMCardElimination(name) {
            const card = llmCardsGrid.querySelector(`[data-character="${name}"]`);
            if (gameState.llmEliminated.has(name)) {
                gameState.llmEliminated.delete(name);
                card.classList.remove('eliminated');
            } else {
                gameState.llmEliminated.add(name);
                card.classList.add('eliminated');
            }
        }

        // Function for LLM to eliminate characters from its board
        function eliminateCharacter(characterName) {
            // Validate character name exists
            if (!characters.includes(characterName)) {
                console.warn(`Invalid character name: ${characterName}`);
                return { success: false, message: `Character "${characterName}" not found` };
            }

            // Check if already eliminated
            if (gameState.llmEliminated.has(characterName)) {
                return { success: false, message: `Character "${characterName}" is already eliminated` };
            }

            // Eliminate the character from LLM's board
            gameState.llmEliminated.add(characterName);
            const card = llmCardsGrid.querySelector(`[data-character="${characterName}"]`);
            if (card) {
                card.classList.add('eliminated');
            }

            console.log(`LLM eliminated character: ${characterName}`);
            return { success: true, message: `Successfully eliminated ${characterName}` };
        }

        function selectRandomCharacters() {
            const shuffledCharacters = shuffleArray([...characters]);
            gameState.userChosenCharacter = shuffledCharacters[0];
            gameState.opponentChosenCharacter = shuffledCharacters[1];
            
            displayChosenCharacters();
        }

        function displayChosenCharacters() {
            // Display user's chosen character
            const userChosenImage = document.getElementById('userChosenImage');
            
            userChosenImage.src = `guess-who-people/${gameState.userChosenCharacter}.png`;
            userChosenImage.alt = gameState.userChosenCharacter;
            
            userChosenImage.onerror = () => {
                userChosenImage.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjE2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGRkIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPk5vIEltYWdlPC90ZXh0Pjwvc3ZnPg==';
            };

            // Opponent's character stays face-down, but we store the name internally
            console.log(`User's character: ${gameState.userChosenCharacter}`);
            console.log(`Opponent's character: ${gameState.opponentChosenCharacter} (hidden)`);
        }

        async function loadGameBoard() {
            try {
                // Reset game state
                isFirstGameMessage = true;
                conversationHistory = [];
                
                // Select random characters for user and opponent
                selectRandomCharacters();
                
                // Shuffle the characters for random order (same order for both boards)
                gameState.characters = shuffleArray(characters);
                gameState.eliminated.clear();
                gameState.llmEliminated.clear();

                // Clear existing cards
                cardsGrid.innerHTML = '';
                llmCardsGrid.innerHTML = '';

                // Create and add character cards for both boards
                gameState.characters.forEach(name => {
                    // User's board
                    const userCard = createCharacterCard(name);
                    cardsGrid.appendChild(userCard);
                    
                    // LLM's board
                    const llmCard = createLLMCharacterCard(name);
                    llmCardsGrid.appendChild(llmCard);
                });

                // Clear chat messages for new game
                chatMessages.innerHTML = '';

                // Show both grids and hide loading
                loadingBoard.style.display = 'none';
                cardsGrid.style.display = 'grid';
                loadingLLMBoard.style.display = 'none';
                llmCardsGrid.style.display = 'grid';

            } catch (error) {
                console.error('Error loading game board:', error);
                loadingBoard.textContent = 'Error loading characters. Please refresh to try again.';
                loadingLLMBoard.textContent = 'Error loading AI board. Please refresh to try again.';
            }
        }

        function setupPasswordToggle() {
            document.querySelectorAll('.toggle-password').forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const input = toggle.previousElementSibling;
                    if (input.type === 'password') {
                        input.type = 'text';
                        toggle.textContent = 'üôà';
                    } else {
                        input.type = 'password';
                        toggle.textContent = 'üëÅÔ∏è';
                    }
                });
            });
        }

        // Initialize the app
        updateApiKeyStatus();
        updateModelIndicator();
        updateKeyStatusIndicators();
        
        // Load the game board
        loadGameBoard();
        setupPasswordToggle();

        if (!apiKeys[currentProvider]) {
            showApiKeyModal();
        }
    </script>
</body>
</html>
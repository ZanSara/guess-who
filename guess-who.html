<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guess Who</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üßë</text></svg>">
    <link rel="stylesheet" href="style.css"> 
    <script src="openai.js"></script>
    <script src="anthropic.js"></script>
    <script src="gemini.js"></script>
</head>
<body>
    <header>
        <h1>Play "Guess Who" with <span class="model-indicator" id="modelIndicator">...</span>!</h1>
    </header>
    
    <div class="api-key-status" id="apiKeyStatus" onclick="showApiKeyModal()">
        ‚öôÔ∏è
    </div>

    <div class="game-container">
        <div class="board">
            <div class="loading-board" id="loadingBoard">
                Loading characters...
            </div>
            <div class="cards-grid" id="cardsGrid" style="display: none;">
                <!-- Character cards will be loaded here -->
            </div>
        </div>
        <div class="chosen-characters">
            <div class="chosen-character">
                <h3>Your Character</h3>
                <div class="chosen-card" id="userChosenCard">
                    <img id="userChosenImage" src="" alt="">
                </div>
            </div>
            <div class="chosen-character">
                <h3>Opponent's Character</h3>
                <div class="chosen-card face-down" id="opponentChosenCard">
                </div>
            </div>
        </div>
        <div class="chat-container">
            <div class="chat-messages" id="chatMessages">
                <!-- Chat messages will appear here -->
            </div>
            <div class="chat-input">
                <input type="text" id="chatInput" placeholder="Type your message..." onkeypress="handleKeyPress(event)">
                <button onclick="sendMessage()">Send</button>
            </div>
        </div>
        <div class="llm-board">
            <div class="llm-board-header">
                <h3>AI's Board</h3>
            </div>
            <div class="loading-llm-board" id="loadingLLMBoard">
                Loading AI board...
            </div>
            <div class="llm-cards-grid" id="llmCardsGrid" style="display: none;">
                <!-- LLM character cards will be loaded here -->
            </div>
        </div>
    </div>

    <!-- API Key Modal -->
    <div id="apiKeyModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">AI Model Configuration</h2>
                <button class="close-modal" onclick="closeModal()">&times;</button>
            </div>
            <p id="modalDescription">Choose your AI provider and configure your API keys:</p>
            <div id="modalMessage"></div>
            
            <div class="provider-selection">
                <div class="provider-option active" id="openaiProvider" onclick="selectProvider('openai')">
                    <div class="key-status" id="openaiKeyStatus"></div>
                    <strong>OpenAI</strong><br>
                </div>
                <div class="provider-option" id="anthropicProvider" onclick="selectProvider('anthropic')">
                    <div class="key-status" id="anthropicKeyStatus"></div>
                    <strong>Anthropic</strong><br>
                </div>
                <div class="provider-option" id="geminiProvider" onclick="selectProvider('gemini')">
                    <div class="key-status" id="geminiKeyStatus"></div>
                    <strong>Google Gemini</strong><br>
                </div>
            </div>
            
            <div class="model-selection">
                <label for="modelSelect"><strong>Selected Model:</strong></label>
                <select id="modelSelect" onchange="updateSelectedModel()">
                    <option value="gpt-4o">GPT-4o</option>
                    <option value="gpt-4o-mini">GPT-4o Mini</option>
                    <option value="gpt-5">GPT-5</option>
                    <option value="gpt-5-mini">GPT-5 Mini</option>
                    <option value="gpt-5-nano">GPT-5 Nano</option>
                </select>
            </div>

            <div class="api-key-section current" id="openaiSection">
                <h4>OpenAI API Key</h4>
                <div class="key-input-group">
                    <div class="key-input-wrapper">
                        <input type="password" id="openaiKeyInput" placeholder="sk-..." />
                        <span class="toggle-password">üëÅÔ∏è</span>
                    </div>
                    <button class="validate-btn" onclick="validateProviderKey('openai')" id="openaiValidateBtn">Test Key</button>
                </div>
                <div class="key-status-text" id="openaiKeyStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section" id="anthropicSection">
                <h4>Anthropic API Key</h4>
                <div class="key-input-group">
                    <div class="key-input-wrapper">
                        <input type="password" id="anthropicKeyInput" placeholder="sk-ant-..." />
                        <span class="toggle-password">üëÅÔ∏è</span>
                    </div>
                    <button class="validate-btn" onclick="validateProviderKey('anthropic')" id="anthropicValidateBtn">Test Key</button>
                </div>
                <div class="key-status-text" id="anthropicKeyStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section" id="geminiSection">
                <h4>Gemini API Key</h4>
                <div class="key-input-group">
                    <div class="key-input-wrapper">
                        <input type="password" id="geminiKeyInput" placeholder="AIza..." />
                        <span class="toggle-password">üëÅÔ∏è</span>
                    </div>
                    <button class="validate-btn" onclick="validateProviderKey('gemini')" id="geminiValidateBtn">Test Key</button>
                </div>
                <div class="key-status-text" id="geminiKeyStatusText" style="display: none;"></div>
            </div>
            
            <!-- System Prompt Section -->
            <div class="system-prompt-section">
                <h3>System Prompt</h3>
                <p>Customize how the AI behaves in the game. This controls the AI's personality, knowledge, and gameplay style.</p>
                <textarea id="systemPromptTextarea" class="system-prompt-textarea" placeholder="Enter your system prompt here..."></textarea>
                <div class="system-prompt-actions">
                    <button class="reset-prompt-btn" onclick="resetSystemPrompt()">Reset to Default</button>
                </div>
            </div>
            
            <div>
                <button onclick="saveConfiguration()" id="saveButton">Save Configuration</button>
                <button onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.querySelector('.chat-input button');
        const apiKeyModal = document.getElementById('apiKeyModal');
        const apiKeyStatus = document.getElementById('apiKeyStatus');
        const modelIndicator = document.getElementById('modelIndicator');
        const modalMessage = document.getElementById('modalMessage');
        const saveButton = document.getElementById('saveButton');
        const modelSelect = document.getElementById('modelSelect');
        const openaiProvider = document.getElementById('openaiProvider');
        const anthropicProvider = document.getElementById('anthropicProvider');
        const geminiProvider = document.getElementById('geminiProvider');
        
        // New elements for multi-key support
        const openaiKeyInput = document.getElementById('openaiKeyInput');
        const anthropicKeyInput = document.getElementById('anthropicKeyInput');
        const geminiKeyInput = document.getElementById('geminiKeyInput');
        const openaiKeyStatus = document.getElementById('openaiKeyStatus');
        const anthropicKeyStatus = document.getElementById('anthropicKeyStatus');
        const geminiKeyStatus = document.getElementById('geminiKeyStatus');
        const openaiSection = document.getElementById('openaiSection');
        const anthropicSection = document.getElementById('anthropicSection');
        const geminiSection = document.getElementById('geminiSection');
        const openaiKeyStatusText = document.getElementById('openaiKeyStatusText');
        const anthropicKeyStatusText = document.getElementById('anthropicKeyStatusText');
        const geminiKeyStatusText = document.getElementById('geminiKeyStatusText');
        const openaiValidateBtn = document.getElementById('openaiValidateBtn');
        const anthropicValidateBtn = document.getElementById('anthropicValidateBtn');
        const geminiValidateBtn = document.getElementById('geminiValidateBtn');
        
        // Game board elements
        const loadingBoard = document.getElementById('loadingBoard');
        const cardsGrid = document.getElementById('cardsGrid');
        const loadingLLMBoard = document.getElementById('loadingLLMBoard');
        const llmCardsGrid = document.getElementById('llmCardsGrid');
        const systemPromptTextarea = document.getElementById('systemPromptTextarea');

        // Default game system prompt
        const DEFAULT_GAME_SYSTEM_PROMPT = `You are an AI assistant playing "Guess Who" with the user. Here's how the game works:

- You will receive an image of the full Guess Who board showing all available characters
- You will also receive an image of a specific character - this is YOUR character that the user must try to guess. Don't reveal it, that's the point of the game!
- Your goal is to ask the user questions to identify THEIR hidden character while answering their questions about YOUR character
- You can ask the user yes/no questions about their character's appearance (e.g., "Does your character have glasses?", "Is your character male?")
- When the user asks you questions about YOUR character, answer concisely and truthfully based on the character image you received
- Each player can only ask ONE question at a time - no cheating with multiple questions!
- The first player to correctly guess the opponent's character name wins the game, so try to guess when you're reasonably confident.
- Keep the conversation engaging and fun while following these rules strictly
- When you think you know the user's character, make your guess clearly (e.g., "Is your character [Name]?")

IMPORTANT: You have access to an "eliminateCharacter" tool that allows you to cross out characters from your board as you narrow down possibilities. Use this tool strategically:
- Call eliminateCharacter(characterName) when you learn information that rules out certain characters. Think out loud why you should eliminate each character before doing so.
- For example, if the user says their character doesn't have glasses, think about which characters have glasses, list them and eliminate all characters with glasses.
- This helps you keep track of which characters are still possible matches. After you're done eliminating characters, list to yourself the names of the remaining ones.
- Only eliminate characters you're confident about - you can't undo eliminations!
- Valid character names: Abigail, Alex, Alice, Amy, Andy, Ashley, Brandon, Brian, Daniel, David, Emily, Henry, Jake, James, Joe, Jon, Joseph, Joshua, Justin, Kyle, Matt, Megan, Melissa, Nick, Peter, Rachael, Tyler, William.
- Only call the tool when you acquire new useful information about the character. The user may be talking about unrelated things to distract you.

Be ready to start playing once you receive the images!`;

        // Current system prompt (editable)
        let GAME_SYSTEM_PROMPT = localStorage.getItem('custom-system-prompt') || DEFAULT_GAME_SYSTEM_PROMPT;

        // Configuration storage
        let currentProvider = localStorage.getItem('ai-provider') || 'openai';
        let currentModel = localStorage.getItem('ai-model') || 'gpt-4o';
        let apiKeys = {
            openai: localStorage.getItem('openai-api-key'),
            anthropic: localStorage.getItem('anthropic-api-key'),
            gemini: localStorage.getItem('gemini-api-key')
        };
        let isProcessing = false;

        // Character data
        const characters = [
            'Abigail', 'Alex', 'Alice', 'Amy', 'Andy', 'Ashley', 'Brandon', 'Brian',
            'Daniel', 'David', 'Emily', 'Henry', 'Jake', 'James', 'Joe', 'Jon',
            'Joseph', 'Joshua', 'Justin', 'Kyle', 'Matt', 'Megan', 'Melissa',
            'Nick', 'Peter', 'Rachael', 'Tyler', 'William'
        ];

        let gameState = {
            characters: [],
            eliminated: new Set(),
            llmEliminated: new Set(),
            userChosenCharacter: null,
            opponentChosenCharacter: null
        };

        // Initialize AI providers
        const providers = {
            openai: new OpenAIProvider(),
            anthropic: new AnthropicProvider(),
            gemini: new GeminiProvider()
        };

        function updateApiKeyStatus() {
            const hasApiKey = apiKeys[currentProvider];
            if (hasApiKey) {
                apiKeyStatus.className = 'api-key-status set';
            } else {
                apiKeyStatus.className = 'api-key-status not-set';
            }
        }

        function updateKeyStatusIndicators() {
            // Update OpenAI key status indicator
            if (apiKeys.openai) {
                openaiKeyStatus.classList.add('has-key');
            } else {
                openaiKeyStatus.classList.remove('has-key');
            }

            // Update Anthropic key status indicator
            if (apiKeys.anthropic) {
                anthropicKeyStatus.classList.add('has-key');
            } else {
                anthropicKeyStatus.classList.remove('has-key');
            }

            // Update Gemini key status indicator
            if (apiKeys.gemini) {
                geminiKeyStatus.classList.add('has-key');
            } else {
                geminiKeyStatus.classList.remove('has-key');
            }
        }

        function updateModelIndicator() {
            const provider = providers[currentProvider];
            const modelName = provider.models.find(m => m.value === currentModel)?.name || currentModel;
            modelIndicator.textContent = modelName;
        }

        function selectProvider(provider) {
            currentProvider = provider;
            
            // Update provider selection UI
            openaiProvider.classList.remove('active');
            anthropicProvider.classList.remove('active');
            geminiProvider.classList.remove('active');
            document.getElementById(provider + 'Provider').classList.add('active');
            
            // Update section highlighting
            openaiSection.classList.remove('current');
            anthropicSection.classList.remove('current');
            geminiSection.classList.remove('current');
            document.getElementById(provider + 'Section').classList.add('current');
            
            // Update model dropdown
            updateModelDropdown();
            updateApiKeyStatus();
            updateModelIndicator();
        }

        function updateModelDropdown() {
            const provider = providers[currentProvider];
            modelSelect.innerHTML = '';
            
            provider.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.name;
                modelSelect.appendChild(option);
            });
            
            // Set model based on current selection or default
            const savedModel = localStorage.getItem('ai-model');
            if (savedModel && provider.models.some(m => m.value === savedModel)) {
                currentModel = savedModel;
            } else {
                // Set default model for provider
                currentModel = provider.defaultModel;
            }
            modelSelect.value = currentModel;
        }

        function updateSelectedModel() {
            currentModel = modelSelect.value;
        }

        function showApiKeyModal() {
            const modalTitle = document.getElementById('modalTitle');
            const modalDescription = document.getElementById('modalDescription');
            
            modalTitle.textContent = 'Settings';
            modalDescription.textContent = 'Configure your AI provider, API keys, and system prompt:';
            
            // Set up the modal with current configuration
            selectProvider(currentProvider);
            modelSelect.value = currentModel;
            
            // Populate existing API keys
            if (apiKeys.openai) {
                openaiKeyInput.value = apiKeys.openai;
            }
            if (apiKeys.anthropic) {
                anthropicKeyInput.value = apiKeys.anthropic;
            }
            if (apiKeys.gemini) {
                geminiKeyInput.value = apiKeys.gemini;
            }
            
            // Populate system prompt textarea
            systemPromptTextarea.value = GAME_SYSTEM_PROMPT;
            
            // Update key status indicators
            updateKeyStatusIndicators();
            
            // Clear any previous messages
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
            
            apiKeyModal.style.display = 'block';
        }

        function showModalMessage(message, isError = false) {
            modalMessage.innerHTML = `<div class="${isError ? 'error-message' : 'success-message'}">${message}</div>`;
        }

        function closeModal() {
            apiKeyModal.style.display = 'none';
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
        }

        function clearAllKeyStatusTexts() {
            openaiKeyStatusText.style.display = 'none';
            anthropicKeyStatusText.style.display = 'none';
            geminiKeyStatusText.style.display = 'none';
        }

        function showKeyStatus(provider, message, status) {
            let statusElement;
            if (provider === 'openai') {
                statusElement = openaiKeyStatusText;
            } else if (provider === 'anthropic') {
                statusElement = anthropicKeyStatusText;
            } else {
                statusElement = geminiKeyStatusText;
            }
            statusElement.textContent = message;
            statusElement.className = `key-status-text ${status}`;
            statusElement.style.display = 'block';
        }

        async function validateProviderKey(provider) {
            let keyInput, validateBtn;
            if (provider === 'openai') {
                keyInput = openaiKeyInput;
                validateBtn = openaiValidateBtn;
            } else if (provider === 'anthropic') {
                keyInput = anthropicKeyInput;
                validateBtn = anthropicValidateBtn;
            } else {
                keyInput = geminiKeyInput;
                validateBtn = geminiValidateBtn;
            }
            const key = keyInput.value.trim();
            const providerInstance = providers[provider];

            if (!key) {
                showKeyStatus(provider, 'Please enter an API key', 'invalid');
                return false;
            }

            if (provider !== 'gemini' && !key.startsWith(providerInstance.keyPrefix)) {
                showKeyStatus(provider, `API key should start with "${providerInstance.keyPrefix}"`, 'invalid');
                return false;
            }

            validateBtn.disabled = true;
            validateBtn.textContent = 'Testing...';
            showKeyStatus(provider, 'Testing API key...', 'testing');

            try {
                // Get a default model for testing
                const testModel = providerInstance.models[0].value;
                
                await providerInstance.validateApiKey(key, testModel);

                showKeyStatus(provider, '‚úì API key is valid!', 'valid');
                return true;

            } catch (error) {
                showKeyStatus(provider, error.message, 'invalid');
                return false;
            } finally {
                validateBtn.disabled = false;
                validateBtn.textContent = 'Test Key';
            }
        }

        async function saveConfiguration() {
            const openaiKey = openaiKeyInput.value.trim();
            const anthropicKey = anthropicKeyInput.value.trim();
            const geminiKey = geminiKeyInput.value.trim();
            
            // Validate that the selected provider has a key
            let selectedProviderKey;
            if (currentProvider === 'openai') {
                selectedProviderKey = openaiKey;
            } else if (currentProvider === 'anthropic') {
                selectedProviderKey = anthropicKey;
            } else {
                selectedProviderKey = geminiKey;
            }

            if (!selectedProviderKey) {
                showModalMessage(`Please enter an API key for ${currentProvider.charAt(0).toUpperCase() + currentProvider.slice(1)} to use this provider.`, true);
                return;
            }

            saveButton.disabled = true;
            saveButton.textContent = 'Saving...';

            try {
                // Save OpenAI key if provided
                if (openaiKey) {
                    apiKeys.openai = openaiKey;
                    localStorage.setItem('openai-api-key', openaiKey);
                } else if (apiKeys.openai) {
                    // Keep existing key if no new one provided
                    openaiKeyInput.value = apiKeys.openai;
                }

                // Save Anthropic key if provided
                if (anthropicKey) {
                    apiKeys.anthropic = anthropicKey;
                    localStorage.setItem('anthropic-api-key', anthropicKey);
                } else if (apiKeys.anthropic) {
                    // Keep existing key if no new one provided
                    anthropicKeyInput.value = apiKeys.anthropic;
                }

                // Save Gemini key if provided
                if (geminiKey) {
                    apiKeys.gemini = geminiKey;
                    localStorage.setItem('gemini-api-key', geminiKey);
                } else if (apiKeys.gemini) {
                    // Keep existing key if no new one provided
                    geminiKeyInput.value = apiKeys.gemini;
                }

                // Save system prompt
                const newPrompt = systemPromptTextarea.value.trim();
                if (newPrompt) {
                    GAME_SYSTEM_PROMPT = newPrompt;
                    localStorage.setItem('custom-system-prompt', newPrompt);
                } else {
                    GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                    localStorage.removeItem('custom-system-prompt');
                }

                // Save current provider and model
                localStorage.setItem('ai-provider', currentProvider);
                localStorage.setItem('ai-model', currentModel);

                // Update UI
                updateApiKeyStatus();
                updateModelIndicator();
                updateKeyStatusIndicators();

                showModalMessage('Configuration saved successfully!', false);

                // Close modal after delay
                setTimeout(() => {
                    closeModal();
                }, 500);

            } catch (error) {
                showModalMessage(error.message, true);
            } finally {
                saveButton.disabled = false;
                saveButton.textContent = 'Save Configuration';
            }
        }

                async function validateOpenAIKey(key, model) {
            const params = {
                model: model,
                messages: [{ role: 'user', content: 'test' }],
                stream: false
            };

            if (model.includes('gpt-5')) {
                params.max_completion_tokens = 1;
            } else {
                params.max_tokens = 1;
            }

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${key}`
                },
                body: JSON.stringify(params)
            });

            if (response.status === 401) {
                throw new Error('Invalid API key. Please check your OpenAI API key and try again.');
            } else if (response.status === 429) {
                throw new Error('Rate limit exceeded. Your API key is valid but you\'ve hit the rate limit.');
            } else if (response.status === 403) {
                throw new Error('API key does not have access to the required model.');
            } else if (!response.ok) {
                throw new Error(`API validation failed (${response.status}). Please try again.`);
            }
        }

        async function validateAnthropicKey(key, model) {
            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': key,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'user', content: 'Hi' }],
                    max_tokens: 1,
                    stream: false
                })
            });

            if (response.status === 401) {
                throw new Error('Invalid API key. Please check your Anthropic API key and try again.');
            } else if (response.status === 429) {
                throw new Error('Rate limit exceeded. Your API key is valid but you\'ve hit the rate limit.');
            } else if (response.status === 403) {
                throw new Error('API key does not have access to the required model.');
            } else if (response.status === 400) {
                // Check if it's a bad request due to invalid model or key format
                const errorData = await response.json().catch(() => null);
                if (errorData && errorData.error && errorData.error.message) {
                    if (errorData.error.message.includes('model') || errorData.error.message.includes('Model')) {
                        throw new Error('Selected model is not available with this API key.');
                    } else {
                        throw new Error(`API key validation failed: ${errorData.error.message}`);
                    }
                } else {
                    throw new Error('Invalid API key format or request. Please check your Anthropic API key.');
                }
            } else if (!response.ok) {
                const errorData = await response.json().catch(() => null);
                const errorMessage = errorData?.error?.message || `API validation failed (${response.status}). Please try again.`;
                throw new Error(errorMessage);
            }
        }

        async function validateGoogleKey(key, model) {
            const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            if (response.status === 400) {
                throw new Error('Invalid API key. Please check your Google API key and try again.');
            } else if (response.status === 429) {
                throw new Error('Rate limit exceeded. Your API key is valid but you\'ve hit the rate limit.');
            } else if (response.status === 403) {
                throw new Error('API key does not have access to the required model.');
            } else if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error.message || `API validation failed (${response.status}). Please try again.`);
            }
        }


        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        function addMessage(content, isUser = false) {
            const messageElement = document.createElement('div');
            messageElement.className = `message ${isUser ? 'user-message' : 'gpt-message'}`;
            messageElement.textContent = content;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function showTypingIndicator() {
            const typingElement = document.createElement('div');
            typingElement.className = 'typing-indicator';
            typingElement.innerHTML = `
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            `;
            chatMessages.appendChild(typingElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            return typingElement;
        }

        function setProcessingState(processing) {
            isProcessing = processing;
            sendButton.disabled = processing;
            chatInput.disabled = processing;
            if (processing) {
                sendButton.textContent = 'Sending...';
            } else {`You are a helpful AI assistant playing a game of "Guess Who" with the user. Be engaging and fun while helping them play the game.`
                sendButton.textContent = 'Send';
            }
        }

        async function getImageAsBase64(imagePath) {
            try {
                const response = await fetch(imagePath);
                const blob = await response.blob();
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64 = reader.result.split(',')[1]; // Remove data:image/png;base64, prefix
                        resolve(base64);
                    };
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('Error loading image:', error);
                return '';
            }
        }

        // Track if this is the first message of the game
        let isFirstGameMessage = true;
        
        // Conversation history
        let conversationHistory = [];

        // Function definitions for AI tools
        const ELIMINATE_CHARACTER_FUNCTION = {
            name: 'eliminateCharacter',
            description: 'Eliminate a character from your board when you learn they cannot be the user\'s character',
            parameters: {
                type: 'object',
                properties: {
                    characterName: {
                        type: 'string',
                        description: 'The exact name of the character to eliminate from the board',
                        enum: characters
                    }
                },
                required: ['characterName']
            }
        };

        async function callOpenAI(message, isFirstMessage = false) {
            const messages = [];
            
            // Always add system message
            messages.push({
                role: 'system',
                content: GAME_SYSTEM_PROMPT
            });
            
            if (isFirstMessage) {
                // Add user message with board image and opponent character image
                const firstUserMessage = {
                    role: 'user',
                    content: [
                        {
                            type: 'text',
                            text: `Let's play Guess Who! Here's the game board and your character. ${message}`
                        },
                        {
                            type: 'image_url',
                            image_url: {
                                url: `data:image/png;base64,${await getImageAsBase64('./full-board.png')}`
                            }
                        },
                        {
                            type: 'image_url',
                            image_url: {
                                url: `data:image/png;base64,${await getImageAsBase64(`./guess-who-people/${gameState.opponentChosenCharacter}.png`)}`
                            }
                        }
                    ]
                };
                messages.push(firstUserMessage);
                // Store in conversation history
                conversationHistory.push(firstUserMessage);
            } else {
                // Add all conversation history
                messages.push(...conversationHistory);
                
                // Add current user message
                const currentUserMessage = {
                    role: 'user',
                    content: message
                };
                messages.push(currentUserMessage);
                // Store in conversation history
                conversationHistory.push(currentUserMessage);
            }

            const params = {
                model: currentModel,
                messages: messages,
                tools: [
                    {
                        type: 'function',
                        function: ELIMINATE_CHARACTER_FUNCTION
                    }
                ],
                tool_choice: 'auto',
                stream: true
            };

            const response = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${apiKeys.openai}`
                },
                body: JSON.stringify(params)
            });

            if (!response.ok) {
                if (response.status === 401) {
                    throw new Error('Invalid API key. Please check your OpenAI API key.');
                } else if (response.status === 429) {
                    throw new Error('Rate limit exceeded. Please try again later.');
                } else {
                    throw new Error(`API request failed: ${response.status}`);
                }
            }

            return response;
        }

        async function callAnthropic(message, isFirstMessage = false) {
            const messages = [];
            
            if (isFirstMessage) {
                // Add user message with images for Anthropic
                const firstUserMessage = {
                    role: 'user',
                    content: [
                        {
                            type: 'text',
                            text: `Let's play Guess Who! Here's the game board and your character. ${message}`
                        },
                        {
                            type: 'image',
                            source: {
                                type: 'base64',
                                media_type: 'image/png',
                                data: await getImageAsBase64('./full-board.png')
                            }
                        },
                        {
                            type: 'image',
                            source: {
                                type: 'base64',
                                media_type: 'image/png',
                                data: await getImageAsBase64(`./guess-who-people/${gameState.opponentChosenCharacter}.png`)
                            }
                        }
                    ]
                };
                messages.push(firstUserMessage);
                // Store in conversation history (without images for subsequent messages)
                conversationHistory.push({
                    role: 'user',
                    content: `Let's play Guess Who! Here's the game board and your character. ${message}`
                });
            } else {
                // Add all conversation history
                messages.push(...conversationHistory);
                
                // Add current user message
                const currentUserMessage = {
                    role: 'user',
                    content: message
                };
                messages.push(currentUserMessage);
                // Store in conversation history
                conversationHistory.push(currentUserMessage);
            }

            const response = await fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': apiKeys.anthropic,
                    'anthropic-version': '2023-06-01',
                    'anthropic-dangerous-direct-browser-access': 'true'
                },
                body: JSON.stringify({
                    model: currentModel,
                    system: GAME_SYSTEM_PROMPT,
                    messages: messages,
                    tools: [
                        {
                            name: 'eliminateCharacter',
                            description: 'Eliminate a character from your board when you learn they cannot be the user\'s character',
                            input_schema: {
                                type: 'object',
                                properties: {
                                    characterName: {
                                        type: 'string',
                                        description: 'The exact name of the character to eliminate from the board',
                                        enum: characters
                                    }
                                },
                                required: ['characterName']
                            }
                        }
                    ],
                    stream: true,
                    max_tokens: 1000
                })
            });

            if (!response.ok) {
                if (response.status === 401) {
                    throw new Error('Invalid API key. Please check your Anthropic API key.');
                } else if (response.status === 429) {
                    throw new Error('Rate limit exceeded. Please try again later.');
                } else {
                    throw new Error(`API request failed: ${response.status}`);
                }
            }

            return response;
        }

        async function callGemini(message, isFirstMessage = false) {
            const contents = [];
            
            if (isFirstMessage) {
                // Add user message with images for Gemini
                const firstUserMessage = {
                    role: 'user',
                    parts: [
                        { text: `${GAME_SYSTEM_PROMPT}\n\nLet's play Guess Who! Here's the game board and your character. ${message}` },
                        {
                            inlineData: {
                                mimeType: 'image/png',
                                data: await getImageAsBase64('./full-board.png')
                            }
                        },
                        {
                            inlineData: {
                                mimeType: 'image/png',
                                data: await getImageAsBase64(`./guess-who-people/${gameState.opponentChosenCharacter}.png`)
                            }
                        }
                    ]
                };
                contents.push(firstUserMessage);
                // Store in conversation history (text only for subsequent messages)
                conversationHistory.push({
                    role: 'user',
                    parts: [{ text: `Let's play Guess Who! Here's the game board and your character. ${message}` }]
                });
            } else {
                // Add all conversation history
                contents.push(...conversationHistory);
                
                // Add current user message
                const currentUserMessage = {
                    role: 'user',
                    parts: [{ text: message }]
                };
                contents.push(currentUserMessage);
                // Store in conversation history
                conversationHistory.push(currentUserMessage);
            }

            const response = await fetch(`https://generativelanguage.googleapis.com/v1/models/${currentModel}:streamGenerateContent?key=${apiKeys.google}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: contents,
                    tools: [
                        {
                            functionDeclarations: [
                                {
                                    name: 'eliminateCharacter',
                                    description: 'Eliminate a character from your board when you learn they cannot be the user\'s character',
                                    parameters: {
                                        type: 'object',
                                        properties: {
                                            characterName: {
                                                type: 'string',
                                                description: 'The exact name of the character to eliminate from the board',
                                                enum: characters
                                            }
                                        },
                                        required: ['characterName']
                                    }
                                }
                            ]
                        }
                    ],
                    generationConfig: {
                    }
                })
            });

            if (!response.ok) {
                if (response.status === 400) {
                    throw new Error('Invalid API key. Please check your Google API key.');
                } else if (response.status === 429) {
                    throw new Error('Rate limit exceeded. Please try again later.');
                } else {
                    const error = await response.json();
                    throw new Error(error.error.message || `API request failed: ${response.status}`);
                }
            }

            return response;
        }

        async function streamOpenAIResponse(response, messageElement) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let fullResponse = '';
            let toolCalls = [];
            let currentToolCall = null;

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') continue;
                        
                        try {
                            const parsed = JSON.parse(data);
                            const delta = parsed.choices[0].delta;
                            
                            // Handle regular content
                            if (delta && delta.content) {
                                fullResponse += delta.content;
                                messageElement.textContent = fullResponse;
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            }
                            
                            // Handle tool calls
                            if (delta && delta.tool_calls) {
                                for (const toolCallDelta of delta.tool_calls) {
                                    const index = toolCallDelta.index;
                                    
                                    // Initialize tool call if needed
                                    if (!toolCalls[index]) {
                                        toolCalls[index] = {
                                            id: '',
                                            type: 'function',
                                            function: { name: '', arguments: '' }
                                        };
                                    }
                                    
                                    // Update tool call
                                    if (toolCallDelta.id) {
                                        toolCalls[index].id += toolCallDelta.id;
                                    }
                                    if (toolCallDelta.function) {
                                        if (toolCallDelta.function.name) {
                                            toolCalls[index].function.name += toolCallDelta.function.name;
                                        }
                                        if (toolCallDelta.function.arguments) {
                                            toolCalls[index].function.arguments += toolCallDelta.function.arguments;
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            // Ignore parsing errors for incomplete chunks
                        }
                    }
                }
            }

            // Execute any tool calls
            for (const toolCall of toolCalls) {
                if (toolCall.function.name === 'eliminateCharacter') {
                    try {
                        const args = JSON.parse(toolCall.function.arguments);
                        const result = eliminateCharacter(args.characterName);
                        
                        messageElement.textContent = fullResponse;
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } catch (e) {
                        console.error('Error executing tool call:', e);
                    }
                }
            }

            return { 
                response: fullResponse, 
                hasToolCalls: toolCalls.length > 0 
            };
        }

        async function streamAnthropicResponse(response, messageElement) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let fullResponse = '';
            let toolCalls = [];
            let currentToolCall = null;

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                const lines = chunk.split('\n');

                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') continue;
                        
                        try {
                            const parsed = JSON.parse(data);
                            
                            // Handle regular text content
                            if (parsed.type === 'content_block_delta' && parsed.delta && parsed.delta.text) {
                                fullResponse += parsed.delta.text;
                                messageElement.textContent = fullResponse;
                                chatMessages.scrollTop = chatMessages.scrollHeight;
                            }
                            
                            // Handle tool use start
                            if (parsed.type === 'content_block_start' && parsed.content_block && parsed.content_block.type === 'tool_use') {
                                currentToolCall = {
                                    id: parsed.content_block.id,
                                    name: parsed.content_block.name,
                                    input: ''
                                };
                            }
                            
                            // Handle tool use input delta
                            if (parsed.type === 'content_block_delta' && parsed.delta && parsed.delta.partial_json && currentToolCall) {
                                currentToolCall.input += parsed.delta.partial_json;
                            }
                            
                            // Handle tool use end
                            if (parsed.type === 'content_block_stop' && currentToolCall) {
                                toolCalls.push(currentToolCall);
                                currentToolCall = null;
                            }
                        } catch (e) {
                            // Ignore parsing errors for incomplete chunks
                        }
                    }
                }
            }

            // Execute any tool calls
            for (const toolCall of toolCalls) {
                if (toolCall.name === 'eliminateCharacter') {
                    try {
                        const args = JSON.parse(toolCall.input);
                        const result = eliminateCharacter(args.characterName);
                        
                        // Add visual feedback to chat
                        // if (result.success) {
                        //     fullResponse += `\n\n*[Eliminated ${args.characterName} from board]*`;
                        // } else {
                        //     fullResponse += `\n\n*[Failed to eliminate ${args.characterName}: ${result.message}]*`;
                        // }
                        messageElement.textContent = fullResponse;
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } catch (e) {
                        console.error('Error executing tool call:', e);
                    }
                }
            }

            return { 
                response: fullResponse, 
                hasToolCalls: toolCalls.length > 0 
            };
        }

        async function streamGeminiResponse(response, messageElement) {
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let fullResponse = '';
            let buffer = '';
            let toolCalls = [];

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;

                const chunk = decoder.decode(value, { stream: true });
                buffer += chunk;

                // Split by newlines but keep incomplete JSON objects in buffer
                const parts = buffer.split('\n');
                buffer = parts.pop() || ''; // Keep the last incomplete part

                for (const part of parts) {
                    const trimmed = part.trim();
                    if (trimmed && trimmed !== ',' && trimmed !== '[' && trimmed !== ']') {
                        // Remove trailing comma if present
                        const cleanJson = trimmed.endsWith(',') ? trimmed.slice(0, -1) : trimmed;
                        
                        try {
                            const parsed = JSON.parse(cleanJson);
                            if (parsed.candidates && parsed.candidates[0] && parsed.candidates[0].content) {
                                const content = parsed.candidates[0].content;
                                
                                if (content.parts) {
                                    for (const part of content.parts) {
                                        // Handle text content
                                        if (part.text) {
                                            fullResponse += part.text;
                                            messageElement.textContent = fullResponse;
                                            chatMessages.scrollTop = chatMessages.scrollHeight;
                                        }
                                        
                                        // Handle function calls
                                        if (part.functionCall) {
                                            toolCalls.push(part.functionCall);
                                        }
                                    }
                                }
                            }
                        } catch (e) {
                            // Ignore parsing errors for incomplete chunks or structural elements
                        }
                    }
                }
            }

            // Process any remaining buffer content
            if (buffer.trim()) {
                const cleanJson = buffer.trim().endsWith(',') ? buffer.trim().slice(0, -1) : buffer.trim();
                if (cleanJson && cleanJson !== ',' && cleanJson !== '[' && cleanJson !== ']') {
                    try {
                        const parsed = JSON.parse(cleanJson);
                        if (parsed.candidates && parsed.candidates[0] && parsed.candidates[0].content) {
                            const content = parsed.candidates[0].content;
                            
                            if (content.parts) {
                                for (const part of content.parts) {
                                    // Handle text content
                                    if (part.text) {
                                        fullResponse += part.text;
                                        messageElement.textContent = fullResponse;
                                        chatMessages.scrollTop = chatMessages.scrollHeight;
                                    }
                                    
                                    // Handle function calls
                                    if (part.functionCall) {
                                        toolCalls.push(part.functionCall);
                                    }
                                }
                            }
                        }
                    } catch (e) {
                        // Ignore final parsing errors
                    }
                }
            }

            // Execute any tool calls
            for (const toolCall of toolCalls) {
                if (toolCall.name === 'eliminateCharacter') {
                    try {
                        const args = toolCall.args;
                        const result = eliminateCharacter(args.characterName);
                        
                        // Add visual feedback to chat
                        // if (result.success) {
                        //     fullResponse += `\n\n*[Eliminated ${args.characterName} from board]*`;
                        // } else {
                        //     fullResponse += `\n\n*[Failed to eliminate ${args.characterName}: ${result.message}]*`;
                        // }
                        messageElement.textContent = fullResponse;
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                    } catch (e) {
                        console.error('Error executing tool call:', e);
                    }
                }
            }

            return { 
                response: fullResponse, 
                hasToolCalls: toolCalls.length > 0 
            };
        }

        async function callAI(message) {
            console.log('callAI called with:', { message, currentProvider, hasApiKey: !!apiKeys[currentProvider] });
            
            if (!apiKeys[currentProvider]) {
                console.log('No API key found, showing modal');
                showApiKeyModal();
                return;
            }

            setProcessingState(true);
            const typingIndicator = showTypingIndicator();

            try {
                const provider = providers[currentProvider];
                if (!provider) {
                    throw new Error('Unsupported provider: ' + currentProvider);
                }
                
                console.log('Calling API for provider:', currentProvider);
                
                // Add system prompt to conversation history if this is the first message
                let fullConversationHistory = [...conversationHistory];
                if (isFirstGameMessage) {
                    fullConversationHistory.unshift({
                        role: 'system',
                        content: GAME_SYSTEM_PROMPT
                    });
                }
                
                const response = await provider.callAPI(message, currentModel, fullConversationHistory);
                
                // After first message, set flag to false
                isFirstGameMessage = false;

                console.log('API response received, status:', response.status);

                // Remove typing indicator and create message element
                if (typingIndicator && typingIndicator.parentNode) {
                    typingIndicator.remove();
                }
                
                const aiMessageElement = document.createElement('div');
                aiMessageElement.className = 'message gpt-message';
                aiMessageElement.textContent = '';
                chatMessages.appendChild(aiMessageElement);

                // Stream the response
                const result = await provider.streamResponse(response, aiMessageElement);
                const aiResponse = result.response;
                const hasToolCalls = result.hasToolCalls;
                
                // Store AI response in conversation history using provider's format
                conversationHistory.push(provider.formatHistoryMessage('assistant', aiResponse));

                // If the response was only tool calls with no text, prompt again for a conversational response
                if (hasToolCalls && (!aiResponse || aiResponse.trim() === '')) {
                    console.log('AI response was only tool calls, prompting for conversational response...');
                    
                    // Add a follow-up message to get conversational response
                    const followUpMessage = "Please provide your response or next question.";
                    
                    // Add the follow-up message to conversation history
                    conversationHistory.push(provider.formatHistoryMessage('user', followUpMessage));
                    
                    const followUpResponse = await provider.callAPI(followUpMessage, currentModel, conversationHistory);
                    const followUpResult = await provider.streamResponse(followUpResponse, aiMessageElement);
                    const followUpText = followUpResult.response;

                    // Combine the responses
                    const combinedResponse = aiResponse + (aiResponse ? '\n\n' : '') + followUpText;

                    // Update the last assistant message in conversation history
                    conversationHistory[conversationHistory.length - 2] = provider.formatHistoryMessage('assistant', combinedResponse);

                    // Add the follow-up AI response to history
                    conversationHistory.push(provider.formatHistoryMessage('assistant', followUpText));
                }

            } catch (error) {
                console.error('Error calling AI API:', error);
                
                // Remove typing indicator if still present
                if (typingIndicator && typingIndicator.parentNode) {
                    typingIndicator.remove();
                }
                
                // Create error message element
                const errorElement = document.createElement('div');
                errorElement.className = 'message gpt-message';
                errorElement.textContent = `Error: ${error.message}`;
                chatMessages.appendChild(errorElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                if (error.message.includes('Invalid API key')) {
                    apiKeys[currentProvider] = null;
                    localStorage.removeItem(`${currentProvider}-api-key`);
                    updateApiKeyStatus();
                    showApiKeyModal();
                }
            } finally {
                setProcessingState(false);
            }
        }

        function sendMessage() {
            const message = chatInput.value.trim();
            if (message && !isProcessing) {
                console.log('Sending message:', message);
                console.log('Current provider:', currentProvider);
                console.log('Has API key:', !!apiKeys[currentProvider]);
                
                addMessage(message, true);
                
                // Add user message to conversation history using provider's format
                const provider = providers[currentProvider];
                conversationHistory.push(provider.formatHistoryMessage('user', message));
                
                chatInput.value = '';
                callAI(message);
            } else {
                console.log('Message not sent - empty or processing:', { message: !!message, isProcessing });
            }
        }

        window.onclick = function(event) {
            if (event.target === apiKeyModal) {
                closeModal();
            }
        }

        function resetSystemPrompt() {
            if (confirm('Are you sure you want to reset to the default system prompt? This will overwrite your current customizations.')) {
                GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                systemPromptTextarea.value = DEFAULT_GAME_SYSTEM_PROMPT;
                localStorage.removeItem('custom-system-prompt');
                
                // Show success feedback
                const resetButton = document.querySelector('.reset-prompt-btn');
                const originalText = resetButton.textContent;
                resetButton.textContent = 'Reset ‚úì';
                
                setTimeout(() => {
                    resetButton.textContent = originalText;
                }, 1000);
                
                console.log('System prompt reset to default');
            }
        }

        // Game functions
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function createCharacterCard(name) {
            const card = document.createElement('div');
            card.className = 'character-card';
            card.dataset.character = name;
            card.onclick = () => toggleCardElimination(name);

            const img = document.createElement('img');
            img.src = `guess-who-people/${name}.png`;
            img.alt = name;
            img.onerror = () => {
                img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOTAiIGhlaWdodD0iMTIwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiNkZGQiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+Tm8gSW1hZ2U8L3RleHQ+PC9zdmc+';
            };

            card.appendChild(img);

            return card;
        }

        function createLLMCharacterCard(name) {
            const card = document.createElement('div');
            card.className = 'llm-character-card';
            card.dataset.character = name;

            const img = document.createElement('img');
            img.src = `guess-who-people/${name}.png`;
            img.alt = name;
            img.onerror = () => {
                img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzAiIGhlaWdodD0iOTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0iI2RkZCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTAiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
            };

            card.appendChild(img);

            return card;
        }

        function toggleCardElimination(name) {
            const card = cardsGrid.querySelector(`[data-character="${name}"]`);
            if (gameState.eliminated.has(name)) {
                gameState.eliminated.delete(name);
                card.classList.remove('eliminated');
            } else {
                gameState.eliminated.add(name);
                card.classList.add('eliminated');
            }
        }

        function toggleLLMCardElimination(name) {
            const card = llmCardsGrid.querySelector(`[data-character="${name}"]`);
            if (gameState.llmEliminated.has(name)) {
                gameState.llmEliminated.delete(name);
                card.classList.remove('eliminated');
            } else {
                gameState.llmEliminated.add(name);
                card.classList.add('eliminated');
            }
        }

        // Function for LLM to eliminate characters from its board
        function eliminateCharacter(characterName) {
            // Validate character name exists
            if (!characters.includes(characterName)) {
                console.warn(`Invalid character name: ${characterName}`);
                return { success: false, message: `Character "${characterName}" not found` };
            }

            // Check if already eliminated
            if (gameState.llmEliminated.has(characterName)) {
                return { success: false, message: `Character "${characterName}" is already eliminated` };
            }

            // Eliminate the character from LLM's board
            gameState.llmEliminated.add(characterName);
            const card = llmCardsGrid.querySelector(`[data-character="${characterName}"]`);
            if (card) {
                card.classList.add('eliminated');
            }

            console.log(`LLM eliminated character: ${characterName}`);
            return { success: true, message: `Successfully eliminated ${characterName}` };
        }

        function selectRandomCharacters() {
            const shuffledCharacters = shuffleArray([...characters]);
            gameState.userChosenCharacter = shuffledCharacters[0];
            gameState.opponentChosenCharacter = shuffledCharacters[1];
            
            displayChosenCharacters();
        }

        function displayChosenCharacters() {
            // Display user's chosen character
            const userChosenImage = document.getElementById('userChosenImage');
            
            userChosenImage.src = `guess-who-people/${gameState.userChosenCharacter}.png`;
            userChosenImage.alt = gameState.userChosenCharacter;
            
            userChosenImage.onerror = () => {
                userChosenImage.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjE2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZGRkIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPk5vIEltYWdlPC90ZXh0Pjwvc3ZnPg==';
            };

            // Opponent's character stays face-down, but we store the name internally
            console.log(`User's character: ${gameState.userChosenCharacter}`);
            console.log(`Opponent's character: ${gameState.opponentChosenCharacter} (hidden)`);
        }

        async function loadGameBoard() {
            try {
                // Reset game state
                isFirstGameMessage = true;
                conversationHistory = [];
                
                // Select random characters for user and opponent
                selectRandomCharacters();
                
                // Shuffle the characters for random order (same order for both boards)
                gameState.characters = shuffleArray(characters);
                gameState.eliminated.clear();
                gameState.llmEliminated.clear();

                // Clear existing cards
                cardsGrid.innerHTML = '';
                llmCardsGrid.innerHTML = '';

                // Create and add character cards for both boards
                gameState.characters.forEach(name => {
                    // User's board
                    const userCard = createCharacterCard(name);
                    cardsGrid.appendChild(userCard);
                    
                    // LLM's board
                    const llmCard = createLLMCharacterCard(name);
                    llmCardsGrid.appendChild(llmCard);
                });

                // Clear chat messages for new game
                chatMessages.innerHTML = '';

                // Show both grids and hide loading
                loadingBoard.style.display = 'none';
                cardsGrid.style.display = 'grid';
                loadingLLMBoard.style.display = 'none';
                llmCardsGrid.style.display = 'grid';

            } catch (error) {
                console.error('Error loading game board:', error);
                loadingBoard.textContent = 'Error loading characters. Please refresh to try again.';
                loadingLLMBoard.textContent = 'Error loading AI board. Please refresh to try again.';
            }
        }

        function setupPasswordToggle() {
            document.querySelectorAll('.toggle-password').forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const input = toggle.previousElementSibling;
                    if (input.type === 'password') {
                        input.type = 'text';
                        toggle.textContent = 'üôà';
                    } else {
                        input.type = 'password';
                        toggle.textContent = 'üëÅÔ∏è';
                    }
                });
            });
        }

        // Initialize the app
        updateApiKeyStatus();
        updateModelIndicator();
        updateKeyStatusIndicators();
        
        // Load the game board
        loadGameBoard();
        setupPasswordToggle();

        if (!apiKeys[currentProvider]) {
            showApiKeyModal();
        }
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guess Who</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üßë</text></svg>">
    <link rel="stylesheet" href="style.css"> 
    <script src="openai.js"></script>
    <script src="anthropic.js"></script>
    <script src="gemini.js"></script>
    <script src="openrouter.js"></script>
</head>
<body>
    <header>
        <h1>Play "Guess Who" with LLMs!</h1>
    </header>

    <!-- Tabbed Game Container -->
    <div class="game-container">
        <div class="tab-navigation">
            <button class="tab-button" onclick="switchTab('user-board')">Your Board</button>
            <button class="tab-button active" onclick="switchTab('chat')">Chat</button>
            <button class="tab-button" onclick="switchTab('llm-board')">AI's Board</button>
        </div>
        
        <div class="tab-content">
            <!-- User's Board Tab -->
            <div class="tab-panel" id="user-board">
                <div class="board">
                    <div class="loading-board" id="loadingBoard">
                        Loading characters...
                    </div>
                    <div class="board-content" id="userBoardContent" style="display: none;">
                        <div class="selected-character-row">
                            <div class="selected-character-container" id="userSelectedContainer">
                                <!-- User's selected character will appear here -->
                            </div>
                        </div>
                        <div class="cards-grid" id="cardsGrid">
                            <!-- Character cards will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- LLM's Board Tab -->
            <div class="tab-panel" id="llm-board">
                <div class="llm-board">
                    <div class="loading-llm-board" id="loadingLLMBoard">
                        Loading AI board...
                    </div>
                    <div class="llm-board-content" id="llmBoardContent" style="display: none;">
                        <div class="selected-character-row">
                            <div class="selected-character-container" id="llmSelectedContainer">
                                <!-- AI's selected character will appear here -->
                            </div>
                        </div>
                        <div class="llm-cards-grid" id="llmCardsGrid">
                            <!-- LLM character cards will be loaded here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Chat Tab -->
            <div class="tab-panel active" id="chat">
                <div class="chat-container">
                    <div class="model-indicator-bar">
                        <span>Playing against: </span>
                        <span class="current-model" id="chatModelIndicator">...</span>
                        <button class="settings-button" onclick="showSettings()">Settings</button>
                    </div>
                    <div class="chat-messages" id="chatMessages">
                        <!-- Chat messages will appear here -->
                    </div>
                    <div class="chat-input" id="chatInputContainer" style="display: none;">
                        <input type="text" id="chatInput" placeholder="Type your message..." onkeypress="handleKeyPress(event)">
                        <button onclick="sendMessage()">Send</button>
                    </div>
                    <div class="start-game-container" id="startGameContainer">
                        <button class="start-game-button" onclick="startGame()">Start!</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- API Key Modal -->
    <div id="apiKeyModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="modalTitle">Model Settings</h2>
                <button class="close-modal" onclick="closeModal()">&times;</button>
            </div>
            <div id="modalMessage"></div>            
            <div class="provider-selection">
                <div class="provider-option active" id="openaiProvider" onclick="selectProvider('openai')">
                    <div class="key-status" id="openaiKeyStatus"></div>
                    <strong>OpenAI</strong><br>
                </div>
                <div class="provider-option" id="anthropicProvider" onclick="selectProvider('anthropic')">
                    <div class="key-status" id="anthropicKeyStatus"></div>
                    <strong>Anthropic</strong><br>
                </div>
                <div class="provider-option" id="geminiProvider" onclick="selectProvider('gemini')">
                    <div class="key-status" id="geminiKeyStatus"></div>
                    <strong>Google Gemini</strong><br>
                </div>
                <div class="provider-option" id="openrouterProvider" onclick="selectProvider('openrouter')">
                    <div class="key-status" id="openrouterKeyStatus"></div>
                    <strong>OpenRouter</strong><br>
                </div>
            </div>
            
            <div class="model-selection">
                <select id="modelSelect" onchange="updateSelectedModel()">
                    <option value="gpt-4o">GPT-4o</option>
                    <option value="gpt-4o-mini">GPT-4o Mini</option>
                    <option value="gpt-5">GPT-5</option>
                    <option value="gpt-5-mini">GPT-5 Mini</option>
                    <option value="gpt-5-nano">GPT-5 Nano</option>
                </select>
            </div>

            <div class="api-key-section current" id="openaiSection">
                <h4>OpenAI API Key</h4>
                <div class="key-input-group">
                    <div class="key-input-wrapper">
                        <input type="password" id="openaiKeyInput" placeholder="sk-..." />
                        <span class="toggle-password">üëÅÔ∏è</span>
                    </div>
                    <button class="validate-btn" onclick="validateProviderKey('openai')" id="openaiValidateBtn">Test Key</button>
                </div>
                <div class="key-status-text" id="openaiKeyStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section" id="anthropicSection">
                <h4>Anthropic API Key</h4>
                <div class="key-input-group">
                    <div class="key-input-wrapper">
                        <input type="password" id="anthropicKeyInput" placeholder="sk-ant-..." />
                        <span class="toggle-password">üëÅÔ∏è</span>
                    </div>
                    <button class="validate-btn" onclick="validateProviderKey('anthropic')" id="anthropicValidateBtn">Test Key</button>
                </div>
                <div class="key-status-text" id="anthropicKeyStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section" id="geminiSection">
                <h4>Gemini API Key</h4>
                <div class="key-input-group">
                    <div class="key-input-wrapper">
                        <input type="password" id="geminiKeyInput" placeholder="AIza..." />
                        <span class="toggle-password">üëÅÔ∏è</span>
                    </div>
                    <button class="validate-btn" onclick="validateProviderKey('gemini')" id="geminiValidateBtn">Test Key</button>
                </div>
                <div class="key-status-text" id="geminiKeyStatusText" style="display: none;"></div>
            </div>

            <div class="api-key-section" id="openrouterSection">
                <h4>OpenRouter API Key</h4>
                <div class="key-input-group">
                    <div class="key-input-wrapper">
                        <input type="password" id="openrouterKeyInput" placeholder="sk-or-..." />
                        <span class="toggle-password">üëÅÔ∏è</span>
                    </div>
                    <button class="validate-btn" onclick="validateProviderKey('openrouter')" id="openrouterValidateBtn">Test Key</button>
                </div>
                <div class="key-status-text" id="openrouterKeyStatusText" style="display: none;"></div>
            </div>
            
            <details>
                <summary>Advanced</summary>
                
                <!-- Game Options Section -->
                <div class="game-options-section">
                    <h3>Game Options</h3>
                    <div class="option-item">
                        <label class="toggle-label">
                            <input type="checkbox" id="showLLMCharacter" onchange="toggleLLMCharacterVisibility()">
                            <span class="toggle-slider"></span>
                            Uncover AI's selected character
                        </label>
                        <p class="option-description">Flip the AI's character card to reveal its identity. It's <i>technically</i> cheating, but it's useful to make sure the LLM is not lying to you üòâ</p>
                    </div>
                </div>
                
                <!-- System Prompt Section -->
                <div class="system-prompt-section">
                    <h3>System Prompt</h3>
                    <p>Customize how the AI behaves in the game. This controls the AI's personality, knowledge, and gameplay style.</p>
                    <textarea id="systemPromptTextarea" class="system-prompt-textarea" placeholder="Enter your system prompt here..."></textarea>
                    <div class="system-prompt-actions">
                        <button class="reset-prompt-btn" onclick="resetSystemPrompt()">Reset to Default</button>
                    </div>
                </div>
            </details>

            <div>
                <button onclick="saveConfiguration()" id="saveButton">Save Configuration</button>
                <button onclick="closeModal()">Cancel</button>
            </div>
            
        </div>
    </div>

    <script>
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const sendButton = document.querySelector('.chat-input button');
        const apiKeyModal = document.getElementById('apiKeyModal');
        const modalMessage = document.getElementById('modalMessage');
        const saveButton = document.getElementById('saveButton');
        const modelSelect = document.getElementById('modelSelect');
        const chatModelIndicator = document.getElementById('chatModelIndicator');
        const openaiProvider = document.getElementById('openaiProvider');
        const anthropicProvider = document.getElementById('anthropicProvider');
        const geminiProvider = document.getElementById('geminiProvider');
        const openrouterProvider = document.getElementById('openrouterProvider');
        
        // New elements for multi-key support
        const openaiKeyInput = document.getElementById('openaiKeyInput');
        const anthropicKeyInput = document.getElementById('anthropicKeyInput');
        const geminiKeyInput = document.getElementById('geminiKeyInput');
        const openrouterKeyInput = document.getElementById('openrouterKeyInput');
        const openaiKeyStatus = document.getElementById('openaiKeyStatus');
        const anthropicKeyStatus = document.getElementById('anthropicKeyStatus');
        const geminiKeyStatus = document.getElementById('geminiKeyStatus');
        const openrouterKeyStatus = document.getElementById('openrouterKeyStatus');
        const openaiSection = document.getElementById('openaiSection');
        const anthropicSection = document.getElementById('anthropicSection');
        const geminiSection = document.getElementById('geminiSection');
        const openrouterSection = document.getElementById('openrouterSection');
        const openaiKeyStatusText = document.getElementById('openaiKeyStatusText');
        const anthropicKeyStatusText = document.getElementById('anthropicKeyStatusText');
        const geminiKeyStatusText = document.getElementById('geminiKeyStatusText');
        const openrouterKeyStatusText = document.getElementById('openrouterKeyStatusText');
        const openaiValidateBtn = document.getElementById('openaiValidateBtn');
        const anthropicValidateBtn = document.getElementById('anthropicValidateBtn');
        const geminiValidateBtn = document.getElementById('geminiValidateBtn');
        const openrouterValidateBtn = document.getElementById('openrouterValidateBtn');
        
        // Game board elements
        const loadingBoard = document.getElementById('loadingBoard');
        const cardsGrid = document.getElementById('cardsGrid');
        const loadingLLMBoard = document.getElementById('loadingLLMBoard');
        const llmCardsGrid = document.getElementById('llmCardsGrid');
        const systemPromptTextarea = document.getElementById('systemPromptTextarea');

        // Default game system prompt (loaded from file)
        let DEFAULT_GAME_SYSTEM_PROMPT = '';

        // Current system prompt (editable)
        let GAME_SYSTEM_PROMPT = localStorage.getItem('custom-system-prompt') || DEFAULT_GAME_SYSTEM_PROMPT;
        
        // Game options
        let showLLMCharacter = localStorage.getItem('show-llm-character') === 'true';

        // Load default system prompt from file
        async function loadDefaultSystemPrompt() {
            try {
                const response = await fetch('default-system-prompt.txt');
                if (response.ok) {
                    DEFAULT_GAME_SYSTEM_PROMPT = await response.text();
                    // Update GAME_SYSTEM_PROMPT if no custom prompt is set
                    if (!localStorage.getItem('custom-system-prompt')) {
                        GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                    }
                } else {
                    console.warn('Could not load default system prompt file');
                    // Fallback to a basic prompt
                    DEFAULT_GAME_SYSTEM_PROMPT = 'You are an AI assistant playing "Guess Who" with the user.';
                    if (!localStorage.getItem('custom-system-prompt')) {
                        GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                    }
                }
            } catch (error) {
                console.error('Error loading default system prompt:', error);
                // Fallback to a basic prompt
                DEFAULT_GAME_SYSTEM_PROMPT = 'You are an AI assistant playing "Guess Who" with the user.';
                if (!localStorage.getItem('custom-system-prompt')) {
                    GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                }
            }
        }

        // Configuration storage
        let currentProvider = localStorage.getItem('ai-provider') || 'openai';
        let currentModel = localStorage.getItem('ai-model') || 'gpt-4o';
        let apiKeys = {
            openai: localStorage.getItem('openai-api-key'),
            anthropic: localStorage.getItem('anthropic-api-key'),
            gemini: localStorage.getItem('gemini-api-key'),
            openrouter: localStorage.getItem('openrouter-api-key')
        };
        let isProcessing = false;

        // Character data
        const characters = [
            'Abigail', 'Alex', 'Alice', 'Amy', 'Andy', 'Ashley', 'Brandon', 'Brian',
            'Daniel', 'David', 'Emily', 'Henry', 'Jake', 'James', 'Joe', 'Jon',
            'Joseph', 'Joshua', 'Justin', 'Kyle', 'Matt', 'Megan', 'Melissa',
            'Nick', 'Peter', 'Rachael', 'Tyler', 'William'
        ];

        let gameState = {
            characters: [],
            eliminated: new Set(),
            llmEliminated: new Set(),
            userChosenCharacter: null,
            opponentChosenCharacter: null
        };

        // Initialize AI providers
        const providers = {
            openai: new OpenAIProvider(),
            anthropic: new AnthropicProvider(),
            gemini: new GeminiProvider(),
            openrouter: new OpenRouterProvider()
        };

        function updateKeyStatusIndicators() {
            // Update OpenAI key status indicator
            if (apiKeys.openai) {
                openaiKeyStatus.classList.add('has-key');
            } else {
                openaiKeyStatus.classList.remove('has-key');
            }

            // Update Anthropic key status indicator
            if (apiKeys.anthropic) {
                anthropicKeyStatus.classList.add('has-key');
            } else {
                anthropicKeyStatus.classList.remove('has-key');
            }

            // Update Gemini key status indicator
            if (apiKeys.gemini) {
                geminiKeyStatus.classList.add('has-key');
            } else {
                geminiKeyStatus.classList.remove('has-key');
            }

            // Update OpenRouter key status indicator
            if (apiKeys.openrouter) {
                openrouterKeyStatus.classList.add('has-key');
            } else {
                openrouterKeyStatus.classList.remove('has-key');
            }
        }

        function updateModelIndicator() {
            const provider = providers[currentProvider];
            const modelName = provider.models.find(m => m.value === currentModel)?.name || currentModel;
            if (chatModelIndicator) {
                chatModelIndicator.textContent = modelName;
            }
        }

        function selectProvider(provider) {
            currentProvider = provider;
            
            // Update provider selection UI
            openaiProvider.classList.remove('active');
            anthropicProvider.classList.remove('active');
            geminiProvider.classList.remove('active');
            openrouterProvider.classList.remove('active');
            document.getElementById(provider + 'Provider').classList.add('active');
            
            // Update section highlighting
            openaiSection.classList.remove('current');
            anthropicSection.classList.remove('current');
            geminiSection.classList.remove('current');
            openrouterSection.classList.remove('current');
            document.getElementById(provider + 'Section').classList.add('current');
            
            // Update model dropdown
            updateModelDropdown();
            updateModelIndicator();
        }

        async function updateModelDropdown() {
            const provider = providers[currentProvider];
            modelSelect.innerHTML = '';
            
            // For OpenRouter, load models dynamically if not already loaded
            if (currentProvider === 'openrouter') {
                if (!provider.modelsLoaded || provider.models.length === 0) {
                    // Check if we have an API key first
                    if (!provider.getApiKey()) {
                        const noKeyOption = document.createElement('option');
                        noKeyOption.textContent = 'API key required to load models';
                        noKeyOption.disabled = true;
                        modelSelect.appendChild(noKeyOption);
                        return;
                    }
                    
                    try {
                        // Show loading indicator in dropdown
                        const loadingOption = document.createElement('option');
                        loadingOption.textContent = 'Loading models...';
                        loadingOption.disabled = true;
                        modelSelect.appendChild(loadingOption);
                        
                        // Load models from OpenRouter API
                        await provider.loadModels();
                        
                        // Clear loading option
                        modelSelect.innerHTML = '';
                    } catch (error) {
                        console.warn('Failed to load OpenRouter models:', error);
                        // Show error message
                        modelSelect.innerHTML = '';
                        const errorOption = document.createElement('option');
                        errorOption.textContent = 'Failed to load models - check API key';
                        errorOption.disabled = true;
                        modelSelect.appendChild(errorOption);
                        return;
                    }
                }
            }
            
            // Add all available models to dropdown
            provider.models.forEach(model => {
                const option = document.createElement('option');
                option.value = model.value;
                option.textContent = model.name;
                modelSelect.appendChild(option);
            });
            
            // Set model based on current selection or default
            const savedModel = localStorage.getItem('ai-model');
            if (savedModel && provider.models.some(m => m.value === savedModel)) {
                currentModel = savedModel;
            } else {
                // Set default model for provider
                currentModel = provider.defaultModel;
            }
            modelSelect.value = currentModel;
        }

        function updateSelectedModel() {
            const newModel = modelSelect.value;
            if (newModel !== currentModel) {
                currentModel = newModel;
                // Update the model indicator
                updateModelIndicator();
                // Save the new model selection
                localStorage.setItem('ai-model', currentModel);
                // Reload the page to ensure clean state with new model
                location.reload();
            }
        }

        function showSettings() {
            const modalTitle = document.getElementById('modalTitle');
            
            // Set up the modal with current configuration
            selectProvider(currentProvider);
            modelSelect.value = currentModel;
            
            // Populate existing API keys
            if (apiKeys.openai) {
                openaiKeyInput.value = apiKeys.openai;
            }
            if (apiKeys.anthropic) {
                anthropicKeyInput.value = apiKeys.anthropic;
            }
            if (apiKeys.gemini) {
                geminiKeyInput.value = apiKeys.gemini;
            }
            if (apiKeys.openrouter) {
                openrouterKeyInput.value = apiKeys.openrouter;
            }
            
            // Populate system prompt textarea
            systemPromptTextarea.value = GAME_SYSTEM_PROMPT;
            
            // Set checkbox state for LLM character visibility
            document.getElementById('showLLMCharacter').checked = showLLMCharacter;
            
            // Update key status indicators
            updateKeyStatusIndicators();
            
            // Clear any previous messages
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
            
            apiKeyModal.style.display = 'block';
        }

        function showModalMessage(message, isError = false) {
            modalMessage.innerHTML = `<div class="${isError ? 'error-message' : 'success-message'}">${message}</div>`;
        }

        function closeModal() {
            apiKeyModal.style.display = 'none';
            modalMessage.innerHTML = '';
            clearAllKeyStatusTexts();
        }

        function clearAllKeyStatusTexts() {
            openaiKeyStatusText.style.display = 'none';
            anthropicKeyStatusText.style.display = 'none';
            geminiKeyStatusText.style.display = 'none';
            openrouterKeyStatusText.style.display = 'none';
        }

        function showKeyStatus(provider, message, status) {
            let statusElement;
            if (provider === 'openai') {
                statusElement = openaiKeyStatusText;
            } else if (provider === 'anthropic') {
                statusElement = anthropicKeyStatusText;
            } else if (provider === 'gemini') {
                statusElement = geminiKeyStatusText;
            } else if (provider === 'openrouter') {
                statusElement = openrouterKeyStatusText;
            }
            statusElement.textContent = message;
            statusElement.className = `key-status-text ${status}`;
            statusElement.style.display = 'block';
        }

        async function validateProviderKey(provider) {
            let keyInput, validateBtn;
            if (provider === 'openai') {
                keyInput = openaiKeyInput;
                validateBtn = openaiValidateBtn;
            } else if (provider === 'anthropic') {
                keyInput = anthropicKeyInput;
                validateBtn = anthropicValidateBtn;
            } else if (provider === 'gemini') {
                keyInput = geminiKeyInput;
                validateBtn = geminiValidateBtn;
            } else if (provider === 'openrouter') {
                keyInput = openrouterKeyInput;
                validateBtn = openrouterValidateBtn;
            }
            const key = keyInput.value.trim();
            const providerInstance = providers[provider];

            if (!key) {
                showKeyStatus(provider, 'Please enter an API key', 'invalid');
                return false;
            }

            if (provider !== 'gemini' && !key.startsWith(providerInstance.keyPrefix)) {
                showKeyStatus(provider, `API key should start with "${providerInstance.keyPrefix}"`, 'invalid');
                return false;
            }

            validateBtn.disabled = true;
            validateBtn.textContent = 'Testing...';
            showKeyStatus(provider, 'Testing API key...', 'testing');

            try {
                // For OpenRouter, no model is needed for validation
                // For other providers, get a default model for testing
                const testModel = provider === 'openrouter' ? null : providerInstance.models[0]?.value;
                
                await providerInstance.validateApiKey(key, testModel);

                showKeyStatus(provider, '‚úì API key is valid!', 'valid');
                
                // If this is OpenRouter and validation succeeded, update the model dropdown
                if (provider === 'openrouter' && currentProvider === 'openrouter') {
                    await updateModelDropdown();
                }
                
                return true;

            } catch (error) {
                showKeyStatus(provider, error.message, 'invalid');
                return false;
            } finally {
                validateBtn.disabled = false;
                validateBtn.textContent = 'Test Key';
            }
        }

        async function saveConfiguration() {
            const openaiKey = openaiKeyInput.value.trim();
            const anthropicKey = anthropicKeyInput.value.trim();
            const geminiKey = geminiKeyInput.value.trim();
            const openrouterKey = openrouterKeyInput.value.trim();
            
            // Validate that the selected provider has a key
            let selectedProviderKey;
            if (currentProvider === 'openai') {
                selectedProviderKey = openaiKey;
            } else if (currentProvider === 'anthropic') {
                selectedProviderKey = anthropicKey;
            } else if (currentProvider === 'gemini') {
                selectedProviderKey = geminiKey;
            } else if (currentProvider === 'openrouter') {
                selectedProviderKey = openrouterKey;
            }

            if (!selectedProviderKey) {
                showModalMessage(`Please enter an API key for ${currentProvider.charAt(0).toUpperCase() + currentProvider.slice(1)} to use this provider.`, true);
                return;
            }

            saveButton.disabled = true;
            saveButton.textContent = 'Saving...';

            try {
                // Save OpenAI key if provided
                if (openaiKey) {
                    apiKeys.openai = openaiKey;
                    localStorage.setItem('openai-api-key', openaiKey);
                } else if (apiKeys.openai) {
                    // Keep existing key if no new one provided
                    openaiKeyInput.value = apiKeys.openai;
                }

                // Save Anthropic key if provided
                if (anthropicKey) {
                    apiKeys.anthropic = anthropicKey;
                    localStorage.setItem('anthropic-api-key', anthropicKey);
                } else if (apiKeys.anthropic) {
                    // Keep existing key if no new one provided
                    anthropicKeyInput.value = apiKeys.anthropic;
                }

                // Save Gemini key if provided
                if (geminiKey) {
                    apiKeys.gemini = geminiKey;
                    localStorage.setItem('gemini-api-key', geminiKey);
                } else if (apiKeys.gemini) {
                    // Keep existing key if no new one provided
                    geminiKeyInput.value = apiKeys.gemini;
                }

                // Save OpenRouter key if provided
                if (openrouterKey) {
                    apiKeys.openrouter = openrouterKey;
                    localStorage.setItem('openrouter-api-key', openrouterKey);
                } else if (apiKeys.openrouter) {
                    // Keep existing key if no new one provided
                    openrouterKeyInput.value = apiKeys.openrouter;
                }

                // Save system prompt
                const newPrompt = systemPromptTextarea.value.trim();
                if (newPrompt) {
                    GAME_SYSTEM_PROMPT = newPrompt;
                    localStorage.setItem('custom-system-prompt', newPrompt);
                } else {
                    GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                    localStorage.removeItem('custom-system-prompt');
                }

                // Save current provider and model
                localStorage.setItem('ai-provider', currentProvider);
                localStorage.setItem('ai-model', currentModel);

                // Update UI
                updateModelIndicator();
                updateKeyStatusIndicators();

                showModalMessage('Configuration saved successfully!', false);

                // Close modal after delay
                setTimeout(() => {
                    closeModal();
                }, 500);

            } catch (error) {
                showModalMessage(error.message, true);
            } finally {
                saveButton.disabled = false;
                saveButton.textContent = 'Save Configuration';
            }
        }


        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        function addMessage(content, isUser = false) {
            const messageElement = document.createElement('div');
            messageElement.className = `message ${isUser ? 'user-message' : 'gpt-message'}`;
            messageElement.textContent = content;
            chatMessages.appendChild(messageElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function showTypingIndicator() {
            const typingElement = document.createElement('div');
            typingElement.className = 'typing-indicator';
            typingElement.innerHTML = `
                <div class="typing-dots">
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                    <div class="typing-dot"></div>
                </div>
            `;
            chatMessages.appendChild(typingElement);
            chatMessages.scrollTop = chatMessages.scrollHeight;
            return typingElement;
        }

        function setProcessingState(processing) {
            isProcessing = processing;
            if (sendButton) {
                sendButton.disabled = processing;
                if (processing) {
                    sendButton.textContent = 'Sending...';
                } else {
                    sendButton.textContent = 'Send';
                }
            }
            if (chatInput) {
                chatInput.disabled = processing;
            }
        }

        async function getImageAsBase64(imagePath) {
            try {
                const response = await fetch(imagePath);
                const blob = await response.blob();
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        const base64 = reader.result.split(',')[1]; // Remove data:image/png;base64, prefix
                        resolve(base64);
                    };
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error('Error loading image:', error);
                return '';
            }
        }

        // Track if this is the first message of the game
        let isFirstGameMessage = true;

        // Function definitions for AI tools
        const ELIMINATE_CHARACTER_FUNCTION = {
            name: 'eliminateCharacter',
            description: 'Eliminate a character from your board when you learn they cannot be the user\'s character',
            parameters: {
                type: 'object',
                properties: {
                    characterName: {
                        type: 'string',
                        description: 'The exact name of the character to eliminate from the board',
                        enum: characters
                    }
                },
                required: ['characterName']
            }
        };

        async function callAI(message) {
            console.log('callAI called with:', { message, currentProvider, hasApiKey: !!apiKeys[currentProvider] });
            
            if (!apiKeys[currentProvider]) {
                console.log('No API key found, showing modal');
                showSettings();
                return;
            }

            setProcessingState(true);
            const typingIndicator = showTypingIndicator();

            try {
                const provider = providers[currentProvider];
                if (!provider) {
                    throw new Error('Unsupported provider: ' + currentProvider);
                }
                
                console.log('Calling API for provider:', currentProvider);
                
                // Set system prompt if this is the first message
                if (isFirstGameMessage) {
                    provider.setSystemPrompt(GAME_SYSTEM_PROMPT);
                    isFirstGameMessage = false;
                }
                
                // Create multimodal message with character image
                const multimodalMessage = await createMultimodalMessage(message);
                const response = await provider.callAPI(multimodalMessage, currentModel, [ELIMINATE_CHARACTER_FUNCTION]);

                console.log('API response received, status:', response.status);

                // Stream the response - message element will be created when typing indicator is removed
                const result = await provider.streamResponse(response, null, typingIndicator);
                const aiResponse = result.response;
                const hasToolCalls = result.hasToolCalls;
                const toolCalls = result.toolCalls || [];
                
                // Execute tool calls if any
                if (toolCalls.length > 0) {
                    console.log('Executing tool calls:', toolCalls);
                    for (const toolCall of toolCalls) {
                        if (toolCall.function.name === 'eliminateCharacter') {
                            try {
                                const args = JSON.parse(toolCall.function.arguments);
                                const functionResult = eliminateCharacter(args.characterName);
                                console.log('Tool call result:', functionResult);
                                
                                // Display the elimination in the chat
                                if (functionResult.success) {
                                    const eliminationDiv = document.createElement('div');
                                    eliminationDiv.className = 'elimination-notice';
                                    eliminationDiv.textContent = `üö´ Eliminated: ${args.characterName}`;
                                    eliminationDiv.style.cssText = `
                                        background: rgba(255, 0, 0, 0.1);
                                        border-left: 3px solid #ff0000;
                                        padding: 8px 12px;
                                        margin: 4px 0;
                                        font-size: 0.9em;
                                        color: #666;
                                    `;
                                    chatMessages.appendChild(eliminationDiv);
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                }
                            } catch (e) {
                                console.error('Error executing tool call:', e);
                            }
                        }
                    }
                }
                
                // AI response is automatically stored in provider's internal history

                // If the response was only tool calls with no text, prompt again for a conversational response
                if (hasToolCalls && (!aiResponse || aiResponse.trim() === '')) {
                    console.log('AI response was only tool calls, prompting for conversational response...');
                    
                    // Add a follow-up message to get conversational response
                    const followUpMessage = "Please provide your response or next question.";
                    
                    const followUpMultimodal = await createMultimodalMessage(followUpMessage);
                    const followUpResponse = await provider.callAPI(followUpMultimodal, currentModel, [ELIMINATE_CHARACTER_FUNCTION]);
                    const followUpResult = await provider.streamResponse(followUpResponse, aiMessageElement);
                    const followUpText = followUpResult.response;

                    // The provider automatically handles adding messages to its internal history
                }

            } catch (error) {
                console.error('Error calling AI API:', error);
                
                // Remove typing indicator if still present
                if (typingIndicator && typingIndicator.parentNode) {
                    typingIndicator.remove();
                }
                
                // Create error message element
                const errorElement = document.createElement('div');
                errorElement.className = 'message gpt-message';
                errorElement.textContent = `Error: ${error.message}`;
                chatMessages.appendChild(errorElement);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                
                if (error.message.includes('Invalid API key')) {
                    apiKeys[currentProvider] = null;
                    localStorage.removeItem(`${currentProvider}-api-key`);
                    showSettings();
                }
            } finally {
                setProcessingState(false);
            }
        }

        function sendMessage() {
            const message = chatInput.value.trim();
            if (message && !isProcessing) {
                console.log('Sending message:', message);
                console.log('Current provider:', currentProvider);
                console.log('Has API key:', !!apiKeys[currentProvider]);
                
                addMessage(message, true);
                
                chatInput.value = '';
                callAI(message);
            } else {
                console.log('Message not sent - empty or processing:', { message: !!message, isProcessing });
            }
        }

        window.onclick = function(event) {
            if (event.target === apiKeyModal) {
                closeModal();
            }
        }

        function resetSystemPrompt() {
            if (confirm('Are you sure you want to reset to the default system prompt? This will overwrite your current customizations.')) {
                GAME_SYSTEM_PROMPT = DEFAULT_GAME_SYSTEM_PROMPT;
                systemPromptTextarea.value = DEFAULT_GAME_SYSTEM_PROMPT;
                localStorage.removeItem('custom-system-prompt');
                
                // Show success feedback
                const resetButton = document.querySelector('.reset-prompt-btn');
                const originalText = resetButton.textContent;
                resetButton.textContent = 'Reset ‚úì';
                
                setTimeout(() => {
                    resetButton.textContent = originalText;
                }, 1000);
                
                console.log('System prompt reset to default');
            }
        }

        // Game functions
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function createCharacterCard(name) {
            const card = document.createElement('div');
            card.className = 'character-card';
            card.dataset.character = name;
            card.onclick = () => toggleCardElimination(name);

            const img = document.createElement('img');
            img.src = `guess-who-people/${name}.png`;
            img.alt = name;
            img.onerror = () => {
                img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iOTAiIGhlaWdodD0iMTIwIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9IiNkZGQiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9udC1mYW1pbHk9IkFyaWFsIiBmb250LXNpemU9IjEyIiBmaWxsPSIjOTk5IiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+Tm8gSW1hZ2U8L3RleHQ+PC9zdmc+';
            };

            card.appendChild(img);

            return card;
        }

        function createLLMCharacterCard(name) {
            const card = document.createElement('div');
            card.className = 'llm-character-card';
            card.dataset.character = name;

            const img = document.createElement('img');
            img.src = `guess-who-people/${name}.png`;
            img.alt = name;
            img.onerror = () => {
                img.src = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzAiIGhlaWdodD0iOTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0iI2RkZCIvPjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMTAiIGZpbGw9IiM5OTkiIHRleHQtYW5jaG9yPSJtaWRkbGUiIGR5PSIuM2VtIj5ObyBJbWFnZTwvdGV4dD48L3N2Zz4=';
            };

            card.appendChild(img);

            return card;
        }

        function toggleCardElimination(name) {
            const card = cardsGrid.querySelector(`[data-character="${name}"]`);
            if (gameState.eliminated.has(name)) {
                gameState.eliminated.delete(name);
                card.classList.remove('eliminated');
            } else {
                gameState.eliminated.add(name);
                card.classList.add('eliminated');
            }
        }

        function toggleLLMCardElimination(name) {
            const card = llmCardsGrid.querySelector(`[data-character="${name}"]`);
            if (gameState.llmEliminated.has(name)) {
                gameState.llmEliminated.delete(name);
                card.classList.remove('eliminated');
            } else {
                gameState.llmEliminated.add(name);
                card.classList.add('eliminated');
            }
        }

        // Helper functions for image loading
        async function getCharacterImageAsBase64(characterName) {
            try {
                const response = await fetch(`guess-who-people/${characterName}.png`);
                if (!response.ok) {
                    throw new Error(`Failed to load image: ${response.status}`);
                }
                const blob = await response.blob();
                
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function() {
                        const base64 = reader.result.split(',')[1];
                        resolve(base64);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                console.error(`Failed to load character image ${characterName}:`, error);
                return null;
            }
        }

        // Helper function to create multimodal message with images
        async function createMultimodalMessage(textContent, includeBoard = false) {
            const provider = providers[currentProvider];
            if (!provider || !provider.createImageContent) {
                // Fallback to text-only if provider doesn't support images
                return textContent;
            }

            try {
                const content = [{ type: 'text', text: textContent }];
                
                // Add the opponent's chosen character image (what the AI is defending)
                if (gameState.opponentChosenCharacter) {
                    const characterImageBase64 = await getCharacterImageAsBase64(gameState.opponentChosenCharacter);
                    if (characterImageBase64) {
                        const imageContent = provider.createImageContent(characterImageBase64);
                        content.push(imageContent);
                    }
                }
                
                // For OpenAI and Anthropic, return the multimodal message structure
                if (currentProvider === 'openai' || currentProvider === 'anthropic') {
                    return {
                        role: 'user',
                        content: content
                    };
                }
                
                // For Gemini, convert to parts format
                if (currentProvider === 'gemini') {
                    return {
                        role: 'user',
                        parts: content.map(item => {
                            if (item.type === 'text') return { text: item.text };
                            if (item.inlineData) return item;
                            // Handle image_url format and convert to Gemini format
                            if (item.image_url) {
                                const base64Data = item.image_url.url.split(',')[1];
                                return {
                                    inlineData: {
                                        mimeType: 'image/png',
                                        data: base64Data
                                    }
                                };
                            }
                            return item;
                        })
                    };
                }
                
                return textContent; // Fallback
            } catch (error) {
                console.error('Error creating multimodal message:', error);
                return textContent; // Fallback to text-only
            }
        }

        // Function for LLM to eliminate characters from its board
        function eliminateCharacter(characterName) {
            // Validate character name exists
            if (!characters.includes(characterName)) {
                console.warn(`Invalid character name: ${characterName}`);
                return { success: false, message: `Character "${characterName}" not found` };
            }

            // Check if already eliminated
            if (gameState.llmEliminated.has(characterName)) {
                return { success: false, message: `Character "${characterName}" is already eliminated` };
            }

            // Eliminate the character from LLM's board
            gameState.llmEliminated.add(characterName);
            const card = llmCardsGrid.querySelector(`[data-character="${characterName}"]`);
            if (card) {
                card.classList.add('eliminated');
            }

            console.log(`LLM eliminated character: ${characterName}`);
            return { success: true, message: `Successfully eliminated ${characterName}` };
        }

        function selectRandomCharacters() {
            const shuffledCharacters = shuffleArray([...characters]);
            gameState.userChosenCharacter = shuffledCharacters[0];
            gameState.opponentChosenCharacter = shuffledCharacters[1];
            
            console.log(`User's character: ${gameState.userChosenCharacter}`);
            console.log(`Opponent's character: ${gameState.opponentChosenCharacter}`);
        }

        function startGame() {
            // Hide the start game container and show the chat input
            const startGameContainer = document.getElementById('startGameContainer');
            const chatInputContainer = document.getElementById('chatInputContainer');
            
            startGameContainer.style.display = 'none';
            chatInputContainer.style.display = 'flex';
            
            // Generate the initial greeting
            generateInitialGreeting();
        }

        async function generateInitialGreeting() {
            try {
                // Check if we have a valid provider and API key
                if (!apiKeys[currentProvider]) {
                    console.log('No API key available for initial greeting');
                    showSettings();
                    return;
                }

                const provider = providers[currentProvider];
                if (!provider) {
                    console.error('Provider not available:', currentProvider);
                    addMessage('Error: AI provider not available. Please check your configuration.', false);
                    return;
                }

                // Create a simple prompt to generate the greeting
                const greetingPrompt = "Generate a brief, friendly greeting message to start a Guess Who game. Tell the user you're ready to play and ask them for their first question. Keep it conversational and under 2 sentences.";
                
                console.log('Generating initial greeting (canary test)...');
                
                // Set system prompt for the provider
                provider.setSystemPrompt(GAME_SYSTEM_PROMPT);
                
                // Show typing indicator
                const typingIndicator = showTypingIndicator();

                try {
                    const greetingMultimodal = await createMultimodalMessage(greetingPrompt);
                    const response = await provider.callAPI(greetingMultimodal, currentModel, [ELIMINATE_CHARACTER_FUNCTION]);
                    
                    // Stream the response - message element will be created when typing indicator is removed
                    const result = await provider.streamResponse(response, null, typingIndicator);
                    console.log('Initial greeting generated successfully (canary passed)');
                    
                } catch (error) {
                    console.error('Canary test failed - could not generate initial greeting:', error);
                    
                    // Remove typing indicator if still present
                    if (typingIndicator && typingIndicator.parentNode) {
                        typingIndicator.remove();
                    }
                    
                    // Show error message and prompt for API key setup
                    addMessage(`Unable to connect to AI service: ${error.message}`, false);
                    
                    if (error.message.includes('Invalid API key')) {
                        apiKeys[currentProvider] = null;
                        localStorage.removeItem(`${currentProvider}-api-key`);
                        showSettings();
                    }
                }

            } catch (error) {
                console.error('Error in generateInitialGreeting:', error);
                addMessage('Error starting the game. Please check your AI configuration.', false);
            }
        }

        async function loadGameBoard() {
            try {
                // Reset game state
                isFirstGameMessage = true;
                
                // Clear all provider conversation histories
                Object.values(providers).forEach(provider => {
                    provider.clearHistory();
                });
                
                // Select random characters for user and opponent
                selectRandomCharacters();
                
                // Shuffle all characters for the main grid (including selected ones)
                gameState.characters = shuffleArray(characters);
                gameState.eliminated.clear();
                gameState.llmEliminated.clear();

                // Clear existing cards
                cardsGrid.innerHTML = '';
                llmCardsGrid.innerHTML = '';
                document.getElementById('userSelectedContainer').innerHTML = '';
                document.getElementById('llmSelectedContainer').innerHTML = '';

                // Create selected character cards for top rows
                const userSelectedCard = createCharacterCard(gameState.userChosenCharacter);
                userSelectedCard.classList.add('top-selected-character');
                userSelectedCard.onclick = null; // Remove click functionality for top row
                document.getElementById('userSelectedContainer').appendChild(userSelectedCard);

                const llmSelectedCard = createLLMCharacterCard(gameState.opponentChosenCharacter);
                llmSelectedCard.classList.add('top-selected-character');
                document.getElementById('llmSelectedContainer').appendChild(llmSelectedCard);

                // Create and add all character cards for main grids (including selected characters)
                gameState.characters.forEach(name => {
                    // User's board
                    const userCard = createCharacterCard(name);
                    cardsGrid.appendChild(userCard);
                    
                    // LLM's board
                    const llmCard = createLLMCharacterCard(name);
                    llmCardsGrid.appendChild(llmCard);
                });

                // Clear chat messages for new game
                chatMessages.innerHTML = '';

                // Show both board contents and hide loading
                loadingBoard.style.display = 'none';
                document.getElementById('userBoardContent').style.display = 'block';
                loadingLLMBoard.style.display = 'none';
                document.getElementById('llmBoardContent').style.display = 'block';
                
                // Apply LLM character visibility setting
                updateLLMCharacterVisibility();

            } catch (error) {
                console.error('Error loading game board:', error);
                loadingBoard.textContent = 'Error loading characters. Please refresh to try again.';
                loadingLLMBoard.textContent = 'Error loading AI board. Please refresh to try again.';
            }
        }

        function setupPasswordToggle() {
            document.querySelectorAll('.toggle-password').forEach(toggle => {
                toggle.addEventListener('click', () => {
                    const input = toggle.previousElementSibling;
                    if (input.type === 'password') {
                        input.type = 'text';
                        toggle.textContent = 'üôà';
                    } else {
                        input.type = 'password';
                        toggle.textContent = 'üëÅÔ∏è';
                    }
                });
            });
        }

        // Initialize the app
        async function initializeApp() {
            // Load default system prompt first
            await loadDefaultSystemPrompt();
            
            updateModelIndicator();
            updateKeyStatusIndicators();
            
            // Load the game board
            loadGameBoard();
            setupPasswordToggle();

            if (!apiKeys[currentProvider]) {
                showSettings();
            }
        }
        
        // Tab switching functionality
        function switchTab(tabName) {
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Remove active class from all tab panels
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Add active class to clicked button
            event.target.classList.add('active');
            
            // Show the selected tab panel
            document.getElementById(tabName).classList.add('active');
        }

        // Toggle LLM character visibility function
        function toggleLLMCharacterVisibility() {
            showLLMCharacter = document.getElementById('showLLMCharacter').checked;
            localStorage.setItem('show-llm-character', showLLMCharacter.toString());
            updateLLMCharacterVisibility();
        }

        // Update LLM character visibility function
        function updateLLMCharacterVisibility() {
            const llmSelectedCard = document.querySelector('#llmSelectedContainer .llm-character-card');
            if (llmSelectedCard) {
                if (showLLMCharacter) {
                    llmSelectedCard.classList.remove('hidden-character');
                } else {
                    llmSelectedCard.classList.add('hidden-character');
                }
            }
        }

        // Start the app
        initializeApp();
    </script>
</body>
</html>